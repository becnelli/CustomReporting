<!DOCTYPE html>
<html>
<head>
    <title>On-Demand Custom Analytics</title>
    
    <script type="text/javascript" src="/apps/2.0p/sdk-debug.js"></script>
    
    <script type="text/javascript" src="http://code.jquery.com/jquery-1.6.1.min.js"></script>
    <script type="text/javascript" src="http://code.highcharts.com/2.1.6/highcharts.js"></script>
    <script type="text/javascript" src="https://raw.github.com/JoeKuan/Highcharts_ExtJs_4/master/Chart/ux/HighChart.js"></script>
    
    <script type="text/javascript" src="https://raw.github.com/RallyApps/rally_analytics/master/lib/lumenize/deploy/lumenize.js"></script>
    
    
    
    <script type="text/javascript">
        Rally.onReady(function() {
            /**
             * @class Ext.ux.form.field.BoxSelect
             * @extends Ext.form.field.ComboBox
             *
             * BoxSelect for ExtJS 4, a combo box improved for multiple value querying, selection and management.
             *
             * A friendlier combo box for multiple selections that creates easily individually
             * removable labels for each selection, as seen on facebook and other sites. Querying
             * and type-ahead support are also improved for multiple selections.
             *
             * Options and usage mostly remain consistent with the {@link Ext.form.field.ComboBox}
             * control. Some default configuration options have changed, but should still
             * work properly if overridden.
             *
             * Inspired by the SuperBoxSelect component for ExtJS 3 (http://technomedia.co.uk/SuperBoxSelect/examples3.html),
             * which in turn was inspired by the BoxSelect component for ExtJS 2 (http://efattal.fr/en/extjs/extuxboxselect/).
             *
             * Various contributions and suggestions made by many members of the ExtJS community which can be seen
             * in the user extension posting: http://www.sencha.com/forum/showthread.php?134751-Ext.ux.form.field.BoxSelect
             *
             * Many thanks go out to all of those who have contributed, this extension would not be
             * possible without your help.
             *
             * @author kvee_iv http://www.sencha.com/forum/member.php?29437-kveeiv
             * @version 1.3.1
             * @requires BoxSelect.css
             * @xtype boxselect
             */
            Ext.define('Ext.ux.form.field.BoxSelect', {
                extend:'Ext.form.field.ComboBox',
                alias: ['widget.comboboxselect', 'widget.boxselect'],
                requires: ['Ext.selection.Model', 'Ext.data.Store'],
            
                /**
                 * @cfg {Boolean} multiSelect
                 * If set to <code>true</code>, allows the combo field to hold more than one value at a time, and allows selecting
                 * multiple items from the dropdown list. (Defaults to <code>true</code>, the default usage for BoxSelect)
                 */
                multiSelect: true,
            
                /**
                 * @cfg {Boolean} forceSelection
                 * <code>true</code> to restrict the selected value to one of the values in the list,
                 * <code>false</code> to allow the user to set arbitrary text into the field (defaults to <code>true</code>, the default usage for BoxSelect)
                 */
                forceSelection: true,
            
                /**
                 * @cfg {Boolean} selectOnFocus <code>true</code> to automatically select any existing field text when the field
                 * receives input focus (defaults to <code>true</code> for best multi-select usability during querying)
                 */
                selectOnFocus: true,
            
                /**
                 * @cfg {Boolean} triggerOnClick <code>true</code> to activate the trigger when clicking in empty space
                 * in the field. Note that the subsequent behavior of this is controlled by the field's {@link #triggerAction}.
                 * This behavior is similar to that of a basic ComboBox with {@link #editable} <code>false</code>.
                 * (defaults to <code>true</code>).
                 */
                triggerOnClick: true,
            
                /**
                 * @cfg {Boolean} createNewOnEnter
                 * When forceSelection is false, new records can be created by the user. These records are not added to the
                 * combo's store. By default, this creation is triggered by typing the configured 'delimiter'. With
                 * createNewOnEnter set to true, this creation can also be triggered by the 'enter' key. This configuration
                 * option has no effect if forceSelection is true. (defaults to <code>false</code>)
                 * <code>true</code> to allow the user to press 'enter' to create a new record
                 * <code>false</code> to only allow the user to type the configured 'delimiter' to create a new record
                 */
                createNewOnEnter: false,
            
                /**
                 * @cfg {Boolean} createNewOnBlur
                 * Similar to {@link #createNewOnEnter}, createNewOnBlur will create a new record when the field loses focus.
                 * This configuration option has no effect if forceSelection is true. Please note that this behavior is also
                 * affected by the configuration options {@link #autoSelect} and {@link #selectOnTab}. If those are true
                 * and an existing item would have been selected as a result, the partial text the user has entered will
                 * be discarded.
                 * <code>true</code> to create a new record when the field loses focus
                 * <code>false</code> to not create a new record on blur
                 */
                createNewOnBlur: false,
            
                /**
                 * @cfg {Boolean} encodeSubmitValue
                 * Controls the formatting of the form submit value of the field. (defaults to <code>false</code>). This
                 * is not applicable of {@link #multiSelect} is false.
                 * <code>true</code> for the field value to submit as a json encoded array in a single GET/POST variable
                 * <code>false</code> for the field to submit as an array of GET/POST variables
                 */
                encodeSubmitValue: false,
            
                /**
                 * @cfg {Boolean} stacked
                 * When stacked is true, each labelled item will fill to the width of the form field
                 * <code>true</code> to have each labelled item fill the width of the form field
                 * <code>false</code> to have each labelled item size to its displayed contents (defaults to <code>false</code>)
                 */
                stacked: false,
            
                /**
                 * @cfg {Boolean} pinList
                 * When multiSelect is true, the pick list used for the combo will stay open after each selection is made. This
                 * config option has no effect if multiSelect is false.
                 * <code>true</code> to keep the pick list expanded after each multiSelect selection
                 * <code>false</code> to collapse the pick list after each multiSelect selection (defaults to <code>true</code>)
                 */
                pinList: true,
            
                /**
                 * @cfg {Boolean} grow <tt>true</tt> if this field should automatically grow and shrink to its content
                 * (defaults to <tt>true</tt>)
                 */
                grow: true,
            
                /**
                 * @cfg {Number} growMin The minimum height to allow when <tt>{@link Ext.form.field.Text#grow grow}=true</tt>
                 * (defaults to <tt>false</tt>, which allows for natural growth based on selections)
                 */
                growMin: false,
            
                /**
                 * @cfg {Number} growMax The maximum height to allow when <tt>{@link Ext.form.field.Text#grow grow}=true</tt>
                 * (defaults to <tt>false</tt>, which allows for natural growth based on selections)
                 */
                growMax: false,
            
                //private
                componentLayout: 'boxselectfield',
            
                /**
                 * Initialize additional settings and enable simultaneous typeAhead and multiSelect support
                 */
                initComponent: function() {
                    var me = this,
                        typeAhead = me.typeAhead;
            
                    if (typeAhead && !me.editable) {
                        Ext.Error.raise('If typeAhead is enabled the combo must be editable: true -- please change one of those settings.');
                    }
            
                    Ext.apply(me, {
                        typeAhead: false
                    });
            
                    me.callParent(arguments);
            
                    me.typeAhead = typeAhead;
            
                    me.selectionModel = new Ext.selection.Model({
                        store: me.valueStore,
                        mode: 'MULTI',
                        onSelectChange: function(record, isSelected, suppressEvent, commitFn) {
                            commitFn();
                        }
                    });
            
                    if (!Ext.isEmpty(me.delimiter) && me.multiSelect) {
                        me.delimiterEndingRegexp = new RegExp(String(me.delimiter).replace(/[$%()*+.?\[\\]{|}]/g, "\$&") + "$");
                    }
                },
            
                /**
                 * Register events for management controls of labelled items
                 */
                initEvents: function() {
                    var me = this;
            
                    me.callParent(arguments);
            
                    if (!me.enableKeyEvents) {
                        me.mon(me.inputEl, 'keydown', me.onKeyDown, me);
                    }
                    me.mon(me.itemList, 'click', me.onItemListClick, me);
                    me.mon(me.selectionModel, 'selectionchange', me.applyMultiselectItemMarkup, me);
                },
            
                /**
                 * Create a store for the records of our current value based on the main store's model
                 */
                bindStore: function(store, initial) {
                    var me = this,
                        oldStore = me.store;
            
                    if (oldStore) {
                        me.mun(oldStore, 'beforeload', me.onBeforeLoad, me);
                        if (me.valueStore) {
                            me.mun(me.valueStore, 'datachanged', me.applyMultiselectItemMarkup, me);
                            me.valueStore = null;
                        }
                    }
            
                    me.callParent(arguments);
            
                    if (me.store) {
                        me.valueStore = new Ext.data.Store({
                            model: me.store.model,
                            proxy: {
                                type: 'memory'
                            }
                        });
                        me.mon(me.valueStore, 'datachanged', me.applyMultiselectItemMarkup, me);
                        me.mon(me.store, 'beforeload', me.onBeforeLoad, me);
                    }
                },
            
                /**
                 * Add refresh tracking to the picker for selection management
                 */
                createPicker: function() {
                    var me = this,
                        picker = me.callParent(arguments);
            
                    me.mon(picker, {
                        'beforerefresh': me.onBeforeListRefresh,
                        'show': function(pick) {
                            /**
                             * Temporary fix for reapplying maxHeight after shorter list was previously shown
                             */
                            var listEl = picker.listEl,
                                ch = listEl.getHeight();
                            if (ch > picker.maxHeight) {
                                listEl.setHeight(picker.maxHeight);
                            }
                        },
                        scope: me
                    });
            
                    return picker;
                },
            
                /**
                 * Clean up labelled items management controls
                 */
                onDestroy: function() {
                    var me = this;
            
                    Ext.destroyMembers(me, 'selectionModel', 'valueStore');
            
                    me.callParent(arguments);
                },
            
                /**
                 * Overridden to avoid use of placeholder, as our main input field is often empty
                 */
                afterRender: function() {
                    var me = this;
            
                    if (Ext.supports.Placeholder && me.inputEl && me.emptyText) {
                        delete me.inputEl.dom.placeholder;
                    }
            
                    if (me.stacked === true) {
                        me.itemList.addCls('x-boxselect-stacked');
                    }
            
                    if (me.grow) {
                        if (Ext.isNumber(me.growMin) && (me.growMin > 0)) {
                            me.itemList.applyStyles('min-height:'+me.growMin+'px');
                        }
                        if (Ext.isNumber(me.growMax) && (me.growMax > 0)) {
                            me.itemList.applyStyles('max-height:'+me.growMax+'px');
                        }
                    }
            
                    me.applyMultiselectItemMarkup();
            
                    me.callParent(arguments);
            
                },
            
                /**
                 * Overridden to search store snapshot instead of data (if available)
                 */
                findRecord: function(field, value) {
                    var ds = this.store,
                        rec = false,
                        idx;
            
                    if (ds.snapshot) {
                        idx = ds.snapshot.findIndexBy(function(rec) {
                            return rec.get(field) === value;
                        });
                        rec = (idx !== -1) ? ds.snapshot.getAt(idx) : false;
                    } else {
                        idx = ds.findExact(field, value);
                        rec = (idx !== -1) ? ds.getAt(idx) : false;
                    }
            
                    return rec;
                },
            
                /**
                 * When the picker is refreshing, we should ignore selection changes. Otherwise
                 * the value of our field will be changing just because our view of the choices is.
                 */
                onBeforeLoad: function() {
                    this.ignoreSelection++;
                },
            
                /**
                 * Overridden to map previously selected records to the "new" versions of the records
                 * based on value field, if they are part of the new store load
                 */
                onLoad: function() {
                    var me = this,
                        valueField = me.valueField,
                        valueStore = me.valueStore,
                        changed = false;
            
            
                    if (valueStore) {
                        if (!Ext.isEmpty(me.value) && (valueStore.getCount() == 0)) {
                            me.setValue(me.value, false, true);
                        }
            
                        valueStore.suspendEvents();
                        valueStore.each(function(rec) {
                            var r = me.findRecord(valueField, rec.get(valueField)),
                                i = r ? valueStore.indexOf(rec) : -1;
                            if (i >= 0) {
                                valueStore.removeAt(i);
                                valueStore.insert(i, r);
                                changed = true;
                            }
                        });
                        valueStore.resumeEvents();
                        if (changed) {
                            valueStore.fireEvent('datachanged', valueStore);
                        }
                    }
            
                    me.callParent(arguments);
            
                    me.ignoreSelection = Ext.Number.constrain(me.ignoreSelection - 1, 0);
            
                    me.alignPicker();
                },
            
                /**
                 * @private
                 * Used to determine if a record is filtered (for retaining as a multiSelect value)
                 */
                isFilteredRecord: function(record) {
                    var me = this,
                        store = me.store,
                        valueField = me.valueField,
                        storeRecord,
                        filtered = false;
            
                    storeRecord = store.findExact(valueField, record.get(valueField));
            
                    filtered = ((storeRecord === -1) && (!store.snapshot || (me.findRecord(valueField, record.get(valueField)) !== false)));
            
                    filtered = filtered || (!filtered && (storeRecord === -1) && (me.forceSelection !== true) &&
                        (me.valueStore.findExact(valueField, record.get(valueField)) >= 0));
            
                    return filtered;
                },
            
                /**
                 * Overridden to allow for continued querying with multiSelect selections already made
                 */
                doRawQuery: function() {
                    var me = this,
                        rawValue = me.inputEl.dom.value;
            
                    if (me.multiSelect) {
                        rawValue = rawValue.split(me.delimiter).pop();
                    }
            
                    this.doQuery(rawValue, false, true);
                },
            
                /**
                 * When the picker is refreshing, we should ignore selection changes. Otherwise
                 * the value of our field will be changing just because our view of the choices is.
                 */
                onBeforeListRefresh: function() {
                    this.ignoreSelection++;
                },
            
                /**
                 * When the picker is refreshing, we should ignore selection changes. Otherwise
                 * the value of our field will be changing just because our view of the choices is.
                 */
                onListRefresh: function() {
                    this.callParent(arguments);
                    this.ignoreSelection = Ext.Number.constrain(this.ignoreSelection - 1, 0);
                },
            
                /**
                 * Overridden to preserve current labelled items when list is filtered/paged/loaded
                 * and does not include our current value.
                 */
                onListSelectionChange: function(list, selectedRecords) {
                    var me = this,
                        valueStore = me.valueStore,
                        mergedRecords = [],
                        i;
            
                    // Only react to selection if it is not called from setValue, and if our list is
                    // expanded (ignores changes to the selection model triggered elsewhere)
                    if ((me.ignoreSelection <= 0) && me.isExpanded) {
                        // Pull forward records that were already selected or are now filtered out of the store
                        valueStore.each(function(rec) {
                            if (Ext.Array.contains(selectedRecords, rec) || me.isFilteredRecord(rec)) {
                                mergedRecords.push(rec);
                            }
                        });
                        mergedRecords = Ext.Array.merge(mergedRecords, selectedRecords);
            
                        i = Ext.Array.intersect(mergedRecords, valueStore.getRange()).length;
                        if ((i != mergedRecords.length) || (i != me.valueStore.getCount())) {
                            me.setValue(mergedRecords, false);
                            if (!me.multiSelect || !me.pinList) {
                                Ext.defer(me.collapse, 1, me);
                            }
                            if (valueStore.getCount() > 0) {
                                me.fireEvent('select', me, valueStore.getRange());
                            }
                        }
                        me.inputEl.focus();
                        if (!me.pinList) {
                            me.inputEl.dom.value = '';
                        }
                        if (me.selectOnFocus) {
                            me.inputEl.dom.select();
                        }
                    }
                },
            
                /**
                 * Overridden to use valueStore instead of valueModels, for inclusion of filtered records
                 */
                syncSelection: function() {
                    var me = this,
                        picker = me.picker,
                        valueField = me.valueField,
                        pickStore, selection, selModel;
            
                    if (picker) {
                        pickStore = picker.store;
            
                        // From the value, find the Models that are in the store's current data
                        selection = [];
                        if (me.valueStore) {
                            me.valueStore.each(function(rec) {
                                var i = pickStore.findExact(valueField, rec.get(valueField));
                                if (i >= 0) {
                                    selection.push(pickStore.getAt(i));
                                }
                            });
                        }
            
                        // Update the selection to match
                        me.ignoreSelection++;
                        selModel = picker.getSelectionModel();
                        selModel.deselectAll();
                        if (selection.length > 0) {
                            selModel.select(selection);
                        }
                        me.ignoreSelection = Ext.Number.constrain(me.ignoreSelection - 1, 0);
                    }
                },
            
                /**
                 * Overridden to align to itemList size instead of inputEl
                 */
                alignPicker: function() {
                    var me = this,
                        picker, isAbove,
                        aboveSfx = '-above',
                        itemBox = me.itemList ? me.itemList.getBox(false, true) : null;
            
                    if (this.isExpanded) {
                        picker = me.getPicker();
                        var pickerScrollPos = picker.getTargetEl().dom.scrollTop;
                        if (me.matchFieldWidth) {
                            // Auto the height (it will be constrained by min and max width) unless there are no records to display.
                            picker.setSize(itemBox ? itemBox.width : null, picker.store && picker.store.getCount() ? null : 0);
                        }
                        if (picker.isFloating()) {
                            picker.alignTo(me.itemList, me.pickerAlign, me.pickerOffset);
            
                            // add the {openCls}-above class if the picker was aligned above
                            // the field due to hitting the bottom of the viewport
                            isAbove = picker.el.getY() < me.inputEl.getY();
                            me.bodyEl[isAbove ? 'addCls' : 'removeCls'](me.openCls + aboveSfx);
                            picker.el[isAbove ? 'addCls' : 'removeCls'](picker.baseCls + aboveSfx);
                        }
                    }
                },
            
                /**
                 * @private
                 * Get the current cursor position in the input field
                 */
                getCursorPosition: function() {
                    var cursorPos;
                    if (Ext.isIE) {
                        cursorPos = document.selection.createRange();
                        cursorPos.collapse(true);
                        cursorPos.moveStart("character", -this.inputEl.dom.value.length);
                        cursorPos = cursorPos.text.length;
                    } else {
                        cursorPos = this.inputEl.dom.selectionStart;
                    }
                    return cursorPos;
                },
            
                /**
                 * @private
                 * Check to see if the input field has selected text
                 */
                hasSelectedText: function() {
                    var sel, range;
                    if (Ext.isIE) {
                        sel = document.selection;
                        range = sel.createRange();
                        return (range.parentElement() == this.inputEl.dom);
                    } else {
                        return this.inputEl.dom.selectionStart != this.inputEl.dom.selectionEnd;
                    }
                },
            
                /**
                 * Handles keyDown processing of key-based selection of labelled items
                 */
                onKeyDown: function(e, t) {
                    var me = this,
                        key = e.getKey(),
                        rawValue = me.inputEl.dom.value,
                        valueStore = me.valueStore,
                        selModel = me.selectionModel,
                        stopEvent = false,
                        rec, i;
            
                    if (me.readOnly || me.disabled || !me.editable) {
                        return;
                    }
            
                    // Handle keyboard based navigation of selected labelled items
                    if ((valueStore.getCount() > 0) &&
                        ((rawValue == '') || ((me.getCursorPosition() === 0) && !me.hasSelectedText()))) {
                        if ((key == e.BACKSPACE) || (key == e.DELETE)) {
                            if (selModel.getCount() > 0) {
                                me.valueStore.remove(selModel.getSelection());
                            } else {
                                me.valueStore.remove(me.valueStore.last());
                            }
                            me.setValue(me.valueStore.getRange());
                            selModel.deselectAll();
                            stopEvent = true;
                        } else if ((key == e.RIGHT) || (key == e.LEFT)) {
                            if ((selModel.getCount() === 0) && (key == e.LEFT)) {
                                selModel.select(valueStore.last());
                                stopEvent = true;
                            } else if (selModel.getCount() > 0) {
                                rec = selModel.getLastFocused() || selModel.getLastSelected();
                                if (rec) {
                                    i = valueStore.indexOf(rec);
                                    if (key == e.RIGHT) {
                                        if (i < (valueStore.getCount() - 1)) {
                                            selModel.select(i + 1, e.shiftKey);
                                            stopEvent = true;
                                        } else if (!e.shiftKey) {
                                            selModel.deselect(rec);
                                            stopEvent = true;
                                        }
                                    } else if ((key == e.LEFT) && (i > 0)) {
                                        selModel.select(i - 1, e.shiftKey);
                                        stopEvent = true;
                                    }
                                }
                            }
                        } else if (key == e.A && e.ctrlKey) {
                            selModel.selectAll();
                            stopEvent = e.A;
                        }
                        me.inputEl.focus();
                    }
            
                    if (stopEvent) {
                        me.preventKeyUpEvent = stopEvent;
                        e.stopEvent();
                        return;
                    }
            
                    // Prevent key up processing for enter if it is being handled by the picker
                    if (me.isExpanded && (key == e.ENTER) && me.picker.highlightedItem) {
                        me.preventKeyUpEvent = true;
                    }
            
                    if (me.enableKeyEvents) {
                        me.callParent(arguments);
                    }
            
                    if (!e.isSpecialKey() && !e.hasModifier()) {
                        me.selectionModel.deselectAll();
                        me.inputEl.focus();
                    }
                },
            
                /**
                 * Handles auto-selection of labelled items based on this field's delimiter, as well
                 * as the keyUp processing of key-based selection of labelled items.
                 */
                onKeyUp: function(e, t) {
                    var me = this,
                        rawValue = me.inputEl.dom.value,
                        rec;
            
                    if (me.preventKeyUpEvent) {
                        e.stopEvent();
                        if ((me.preventKeyUpEvent === true) || (e.getKey() === me.preventKeyUpEvent)) {
                            delete me.preventKeyUpEvent;
                        }
                        return;
                    }
            
                    if (me.multiSelect && (me.delimiterEndingRegexp && me.delimiterEndingRegexp.test(rawValue)) ||
                        ((me.createNewOnEnter === true) && e.getKey() == e.ENTER)) {
                        rawValue = rawValue.replace(me.delimiterEndingRegexp, '');
                        if (!Ext.isEmpty(rawValue)) {
                            rec = me.valueStore.findExact(me.valueField, rawValue);
                            if (rec >= 0) {
                                rec = me.valueStore.getAt(rec);
                            } else {
                                rec = me.store.findExact(me.valueField, rawValue);
                                if (rec >= 0) {
                                    rec = me.store.getAt(rec);
                                } else {
                                    rec = false;
                                }
                            }
                            if (!rec && !me.forceSelection) {
                                rec = {};
                                rec[me.valueField] = rawValue;
                                rec[me.displayField] = rawValue;
                                rec = new me.valueStore.model(rec);
                            }
                            if (rec) {
                                me.collapse();
                                me.setValue(me.valueStore.getRange().concat(rec));
                                me.inputEl.dom.value = '';
                                me.inputEl.focus();
                            }
                        }
                    }
            
                    me.callParent([e,t]);
            
                    Ext.Function.defer(me.alignPicker, 10, me);
                },
            
                /**
                 * Overridden to get and set the dom value directly for type-ahead suggestion (bypassing get/setRawValue)
                 */
                onTypeAhead: function() {
                    var me = this,
                        displayField = me.displayField,
                        inputElDom = me.inputEl.dom,
                        record = me.store.findRecord(displayField, inputElDom.value),
                        boundList = me.getPicker(),
                        newValue, len, selStart;
            
                    if (record) {
                        newValue = record.get(displayField);
                        len = newValue.length;
                        selStart = inputElDom.value.length;
                        boundList.highlightItem(boundList.getNode(record));
                        if (selStart !== 0 && selStart !== len) {
                            inputElDom.value = newValue;
                            me.selectText(selStart, newValue.length);
                        }
                    }
                },
            
                /**
                 * Delegation control for selecting and removing labelled items or triggering list collapse/expansion
                 */
                onItemListClick: function(evt, el, o) {
                    var me = this,
                        itemEl = evt.getTarget('.x-boxselect-item'),
                        closeEl = itemEl ? evt.getTarget('.x-boxselect-item-close') : false;
            
                    if (me.readOnly || me.disabled) {
                        return;
                    }
            
                    evt.stopPropagation();
            
                    if (itemEl) {
                        if (closeEl) {
                            me.removeByListItemNode(itemEl);
                        } else {
                            me.toggleSelectionByListItemNode(itemEl, evt.shiftKey);
                        }
                        me.inputEl.focus();
                    } else if (me.triggerOnClick) {
                        me.onTriggerClick();
                    }
                },
            
                /**
                 * Build the markup for the labelled items. Template must be built on demand due to ComboBox initComponent
                 * lifecycle for the creation of on-demand stores (to account for automatic valueField/displayField setting)
                 */
                getMultiSelectItemMarkup: function() {
                    var me = this;
            
                    if (!me.multiSelectItemTpl) {
                        if (!me.labelTpl) {
                            me.labelTpl = Ext.create('Ext.XTemplate',
                                '{[values.' + me.displayField + ']}'
                            );
                        } else if (Ext.isString(me.labelTpl)) {
                            me.labelTpl = Ext.create('Ext.XTemplate', me.labelTpl);
                        }
            
                        me.multiSelectItemTpl = [
                            '<tpl for=".">',
                            '<li class="x-boxselect-item ',
                            '<tpl if="this.isSelected(values.'+ me.valueField + ')">',
                            ' selected',
                            '</tpl>',
                            '" qtip="{[typeof values === "string" ? values : values.' + me.displayField + ']}">' ,
                            '<div class="x-boxselect-item-text">{[typeof values === "string" ? values : this.getItemLabel(values)]}</div>',
                            '<div class="x-tab-close-btn x-boxselect-item-close"></div>' ,
                            '</li>' ,
                            '</tpl>',
                            {
                                compile: true,
                                disableFormats: true,
                                isSelected: function(value) {
                                    var i = me.valueStore.findExact(me.valueField, value);
                                    if (i >= 0) {
                                        return me.selectionModel.isSelected(me.valueStore.getAt(i));
                                    }
                                },
                                getItemLabel: function(values) {
                                    return me.getTpl('labelTpl').apply(values);
                                }
                            }
                        ];
                    }
            
                    return this.getTpl('multiSelectItemTpl').apply(Ext.Array.pluck(this.valueStore.getRange(), 'data'));
                },
            
                /**
                 * Update the labelled items rendering
                 */
                applyMultiselectItemMarkup: function() {
                    var me = this,
                        itemList = me.itemList,
                        item;
            
                    if (itemList) {
                        while ((item = me.inputElCt.prev()) != null) {
                            item.remove();
                        }
                        me.inputElCt.insertHtml('beforeBegin', me.getMultiSelectItemMarkup());
                    }
                },
            
                /**
                 * Returns the record from valueStore for the labelled item node
                 */
                getRecordByListItemNode: function(itemEl) {
                    var me = this,
                        itemIdx = 0,
                        searchEl = me.itemList.dom.firstChild;
            
                    while (searchEl && searchEl.nextSibling) {
                        if (searchEl == itemEl) {
                            break;
                        }
                        itemIdx++;
                        searchEl = searchEl.nextSibling;
                    }
                    itemIdx = (searchEl == itemEl) ? itemIdx : false;
            
                    if (itemIdx === false) {
                        return false;
                    }
            
                    return me.valueStore.getAt(itemIdx);
                },
            
                /**
                 * Toggle of labelled item selection by node reference
                 */
                toggleSelectionByListItemNode: function(itemEl, keepExisting) {
                    var me = this,
                        rec = me.getRecordByListItemNode(itemEl);
            
                    if (rec) {
                        if (me.selectionModel.isSelected(rec)) {
                            me.selectionModel.deselect(rec);
                        } else {
                            me.selectionModel.select(rec, keepExisting);
                        }
                    }
                },
            
                /**
                 * Removal of labelled item by node reference
                 */
                removeByListItemNode: function(itemEl) {
                    var me = this,
                        rec = me.getRecordByListItemNode(itemEl);
            
                    if (rec) {
                        me.valueStore.remove(rec);
                        me.setValue(me.valueStore.getRange());
                    }
                },
            
                /**
                 * Intercept calls to getRawValue to pretend there is no inputEl for rawValue handling,
                 * so that we can use inputEl for just the user input.
                 *
                 * **Note that in general, raw values are the rendered value for the input field,
                 * and therefore should not be used for comboboxes or most programmatic logic.**
                 */
                getRawValue: function() {
                    var me = this,
                        inputEl = me.inputEl,
                        result;
                    me.inputEl = false;
                    result = me.callParent(arguments);
                    me.inputEl = inputEl;
                    return result;
                },
            
                /**
                 * Intercept calls to setRawValue to pretend there is no inputEl for rawValue handling,
                 * so that we can use inputEl for just the user input.
                 *
                 * **Note that in general, raw values are the rendered value for the input field,
                 * and therefore should not be used for comboboxes or most programmatic logic.**
                 */
                setRawValue: function(value) {
                    var me = this,
                        inputEl = me.inputEl,
                        result;
            
                    me.inputEl = false;
                    result = me.callParent([value]);
                    me.inputEl = inputEl;
            
                    return result;
                },
            
                /**
                 * Adds a value or values to the current value of the field
                 * @param {mixed} valueMixed The value or values to add to the current value
                 */
                addValue: function(valueMixed) {
                    var me = this;
                    if (valueMixed) {
                        me.setValue(Ext.Array.merge(me.value, Ext.Array.from(valueMixed)));
                    }
                },
            
                /**
                 * Removes a value or values from the current value of the field
                 * @param {mixed} valueMixed The value or values to remove from the current value
                 */
                removeValue: function(valueMixed) {
                    var me = this;
            
                    if (valueMixed) {
                        me.setValue(Ext.Array.difference(me.value, Ext.Array.from(valueMixed)));
                    }
                },
            
                /**
                 * Intercept calls to setValue to use records from the valueStore when available.
                 * Unknown values (if forceSelection is true) will trigger a call to store.load
                 * once to try to retrieve those records. The list of unknown values will be
                 * submitted as the name of the valueField with values separated by the configured
                 * delimiter. This process will cause setValue to asynchronously process.
                 */
                setValue: function(value, doSelect, skipLoad) {
                    var me = this,
                        valueStore = me.valueStore,
                        valueField = me.valueField,
                        record, len, i, valueRecord, h,
                        unknownValues = [];
            
                    if (Ext.isEmpty(value)) {
                        value = null;
                    }
                    if (Ext.isString(value) && me.multiSelect) {
                        value = value.split(me.delimiter);
                    }
                    value = Ext.Array.from(value);
            
                    for (i = 0, len = value.length; i < len; i++) {
                        record = value[i];
                        if (!record || !record.isModel) {
                            valueRecord = valueStore.findExact(valueField, record);
                            if (valueRecord >= 0) {
                                value[i] = valueStore.getAt(valueRecord);
                            } else {
                                valueRecord = me.findRecord(valueField, record);
                                if (!valueRecord) {
                                    if (me.forceSelection) {
                                        unknownValues.push(record);
                                    } else {
                                        valueRecord = {};
                                        valueRecord[me.valueField] = record;
                                        valueRecord[me.displayField] = record;
                                        valueRecord = new me.valueStore.model(valueRecord);
                                    }
                                }
                                if (valueRecord) {
                                    value[i] = valueRecord;
                                }
                            }
                        }
                    }
            
                    if ((skipLoad !== true) && (unknownValues.length > 0) && (me.queryMode === 'remote')) {
                        var params = {};
                        params[me.valueField] = unknownValues.join(me.delimiter);
                        me.store.load({
                            params: params,
                            callback: function() {
                                me.itemList.unmask();
                                me.setValue(value, doSelect, true);
                                me.autoSize();
                            }
                        });
                        return false;
                    }
            
                    /**
                     * For single-select boxes, use the last value
                     */
                    if (!me.multiSelect && (value.length > 0)) {
                        value = value[value.length - 1];
                    }
            
                    me.callParent([value, doSelect]);
                },
            
                /**
                 * Returns the records for the field's current value
                 * @return {Array} The records for the field's current value
                 */
                getValueRecords: function() {
                    return this.valueStore.getRange();
                },
            
                /**
                 * Overridden to optionally allow for submitting the field as a json encoded array.
                 */
                getSubmitData: function() {
                    var me = this,
                        val = me.callParent(arguments);
            
                    if (me.multiSelect && me.encodeSubmitValue && val && val[me.name]) {
                        val[me.name] = Ext.encode(val[me.name]);
                    }
            
                    return val;
                },
            
                /**
                 * Overridden to handle creation of new value for unforced selections
                 */
                beforeBlur: function() {
                    var me = this;
                    me.doQueryTask.cancel();
                    me.assertValue();
                    me.collapse();
                },
            
                /**
                 * Overridden to clear the input field if we are auto-setting a value as we blur.
                 */
                mimicBlur: function() {
                    var me = this;
            
                    if (me.selectOnTab && me.picker && me.picker.highlightedItem) {
                        me.inputEl.dom.value = '';
                    }
            
                    me.callParent(arguments);
                },
            
                /**
                 * Overridden to handle partial-input selections more directly
                 */
                assertValue: function() {
                    var me = this,
                        rawValue = me.inputEl.dom.value,
                        rec = !Ext.isEmpty(rawValue) ? me.findRecordByDisplay(rawValue) : false,
                        value = false;
            
                    if (!rec && !me.forceSelection && me.createNewOnBlur && !Ext.isEmpty(rawValue)) {
                        value = rawValue;
                    } else if (rec) {
                        value = rec;
                    }
            
                    if (value) {
                        me.addValue(value);
                    }
            
                    me.inputEl.dom.value = '';
            
                    me.collapse();
                },
            
                /**
                 * Update the valueStore from the new value and fire change events for UI to respond to
                 */
                checkChange: function() {
                    if (!this.suspendCheckChange && !this.isDestroyed) {
                        var me = this,
                            valueStore = me.valueStore,
                            lastValue = me.lastValue,
                            valueField = me.valueField,
                            newValue = Ext.Array.map(Ext.Array.from(me.value), function(val) {
                                if (val.isModel) {
                                    return val.get(valueField);
                                }
                                return val;
                            }, this).join(this.delimiter);
            
                        if (!me.isEqual(newValue, lastValue)) {
                            valueStore.suspendEvents();
                            valueStore.removeAll();
                            if (Ext.isArray(me.valueModels)) {
                                valueStore.add(me.valueModels);
                            }
                            valueStore.resumeEvents();
                            valueStore.fireEvent('datachanged', valueStore);
            
                            me.lastValue = newValue;
                            me.fireEvent('change', me, newValue, lastValue);
                            me.onChange(newValue, lastValue)
                        }
                    }
                },
            
                /**
                 * Overridden to use value (selection) instead of raw value and to avoid the use of placeholder
                 */
                applyEmptyText : function() {
                    var me = this,
                        emptyText = me.emptyText,
                        inputEl, isEmpty;
            
                    if (me.rendered && emptyText) {
                        isEmpty = Ext.isEmpty(me.value) && !me.hasFocus;
                        inputEl = me.inputEl;
                        if (isEmpty) {
                            inputEl.dom.value = emptyText;
                            inputEl.addCls(me.emptyCls);
                        } else {
                            if (inputEl.dom.value === emptyText) {
                                inputEl.dom.value = '';
                            }
                            inputEl.removeCls(me.emptyCls);
                        }
                    }
                },
            
                /**
                 * Overridden to use inputEl instead of raw value and to avoid the use of placeholder
                 */
                preFocus : function(){
                    var me = this,
                        inputEl = me.inputEl,
                        emptyText = me.emptyText,
                        isEmpty;
            
                    if (emptyText && inputEl.dom.value === emptyText) {
                        inputEl.dom.value = '';
                        isEmpty = true;
                        inputEl.removeCls(me.emptyCls);
                    }
                    if (me.selectOnFocus || isEmpty) {
                        inputEl.dom.select();
                    }
                },
            
                /**
                 * Intercept calls to onFocus to add focusCls, because the base field classes assume this should be applied to inputEl
                 */
                onFocus: function() {
                    var me = this,
                        focusCls = me.focusCls,
                        itemList = me.itemList;
            
                    if (focusCls && itemList) {
                        itemList.addCls(focusCls);
                    }
            
                    me.callParent(arguments);
                },
            
                /**
                 * Intercept calls to onBlur to remove focusCls, because the base field classes assume this should be applied to inputEl
                 */
                onBlur: function() {
                    var me = this,
                        focusCls = me.focusCls,
                        itemList = me.itemList;
            
                    if (focusCls && itemList) {
                        itemList.removeCls(focusCls);
                    }
            
                    me.callParent(arguments);
                },
            
                /**
                 * Intercept calls to renderActiveError to add invalidCls, because the base field classes assume this should be applied to inputEl
                 */
                renderActiveError: function() {
                    var me = this,
                        invalidCls = me.invalidCls,
                        itemList = me.itemList,
                        hasError = me.hasActiveError();
            
                    if (invalidCls && itemList) {
                        itemList[hasError ? 'addCls' : 'removeCls'](me.invalidCls + '-field');
                    }
            
                    me.callParent(arguments);
                },
            
                /**
                 * Ensure inputEl is sized well for user input using the remaining
                 * horizontal space available in the list element
                 *
                 * Automatically grows the field to accomodate the height of the selections up to the
                 * maximum field height allowed.  This only takes effect if <tt>{@link #grow} = true</tt>,
                 * and fires the {@link #autosize} event if the height changes.
                 */
                autoSize: function() {
                    var me = this,
                        height;
            
                    if (me.rendered) {
                        me.doComponentLayout();
                        if (me.grow) {
                            height = me.getHeight();
                            if (height !== me.lastInputHeight) {
                                me.alignPicker();
                                me.fireEvent('autosize', height);
                                me.lastInputHeight = height;
                            }
                        }
                    }
            
                    return me;
                }
            
            }, function() {
                /**
                 * ExtJS 4.0.5 introduced more optimized ways of referencing child elements. As this is
                 * currently a subscriber only release, these registrations are performed here for
                 * backwards compatibility with the currently available public version 4.0.2a
                 */
            
                var useNewSelectors = !Ext.getVersion('extjs').isLessThan('4.0.5'),
                    overrides = {};
            
                if (useNewSelectors) {
                    Ext.apply(overrides, {
                        fieldSubTpl: [
                            '<div class="x-boxselect">',
                            '<ul id="{cmpId}-itemList" class="x-boxselect-list {fieldCls} {typeCls}">',
                            '<li id="{cmpId}-inputElCt" class="x-boxselect-input">',
                            '<input id="{cmpId}-inputEl" type="{type}" ',
                            '<tpl if="name">name="{name}" </tpl>',
                            '<tpl if="size">size="{size}" </tpl>',
                            '<tpl if="tabIdx">tabIndex="{tabIdx}" </tpl>',
                            'class="x-boxselect-input-field" autocomplete="off" />',
                            '</li>',
                            '</ul>',
                            '<div id="{cmpId}-triggerWrap" class="{triggerWrapCls}" role="presentation">',
                            '{triggerEl}',
                            '<div class="{clearCls}" role="presentation"></div>',
                            '</div>',
                            '<div class="{clearCls}" role="presentation"></div>',
                            '</div>',
                            {
                                compiled: true,
                                disableFormats: true
                            }
                        ],
                        childEls: ['itemList', 'inputEl', 'inputElCt']
                    });
                } else {
                    Ext.apply(overrides, {
                        fieldSubTpl: [
                            '<div class="x-boxselect">',
                            '<ul class="x-boxselect-list {fieldCls} {typeCls}">',
                            '<li class="x-boxselect-input">',
                            '<input id="{id}" type="{type}" ',
                            '<tpl if="name">name="{name}" </tpl>',
                            '<tpl if="size">size="{size}" </tpl>',
                            '<tpl if="tabIdx">tabIndex="{tabIdx}" </tpl>',
                            'class="x-boxselect-input-field" autocomplete="off" />',
                            '</li>',
                            '</ul>',
                            '<div class="{triggerWrapCls}" role="presentation">',
                            '{triggerEl}',
                            '<div class="{clearCls}" role="presentation"></div>',
                            '</div>',
                            '</div>',
                            {
                                compiled: true,
                                disableFormats: true
                            }
                        ],
                        renderSelectors: {
                            itemList: 'ul.x-boxselect-list',
                            inputEl: 'input.x-boxselect-input-field',
                            inputElCt: 'li.x-boxselect-input'
                        }
                    });
                }
            
                Ext.override(this, overrides);
            });
            
            /**
             * This is an amalgamation of the TextArea field layout and the Trigger field layout,
             * with overrides to manage the layout of the field on the itemList wrap instead
             * of the inputEl and to grow based on inputEl wrap positioning instead of
             * raw text value.
             */
            Ext.define('Ext.ux.layout.component.field.BoxSelectField', {
            
                /* Begin Definitions */
            
                alias: ['layout.boxselectfield'],
            
                extend: 'Ext.layout.component.field.Field',
            
                /* End Definitions */
            
                type: 'boxselectfield',
            
                /**
                 * Overridden to use an encoded value instead of raw value
                 */
                beforeLayout: function(width, height) {
                    var me = this,
                        owner = me.owner,
                        lastValue = this.lastValue,
                        value = Ext.encode(owner.value);
                    this.lastValue = value;
                    return me.callParent(arguments) || (owner.grow && value !== lastValue);
                },
            
                /**
                 * Overridden to use itemList instead of inputEl, and to merge trigger field
                 * sizing with text field growability.
                 */
                sizeBodyContents: function(width, height) {
                    var me = this,
                        owner = me.owner,
                        triggerWrap = owner.triggerWrap,
                        triggerWidth = owner.getTriggerWidth(),
                        itemList, inputEl, inputElCt, lastEntry,
                        listBox, listWidth, inputWidth;
            
                    // If we or our ancestor is hidden, we can get a triggerWidth calculation
                    // of 0.  We don't want to resize in this case.
                    if (owner.hideTrigger || owner.readOnly || triggerWidth > 0) {
                        itemList = owner.itemList;
            
                        // Decrease the field's width by the width of the triggers. Both the field and the triggerWrap
                        // are floated left in CSS so they'll stack up side by side.
                        me.setElementSize(itemList, Ext.isNumber(width) ? width - triggerWidth : width, height);
            
                        // Explicitly set the triggerWrap's width, to prevent wrapping
                        triggerWrap.setWidth(triggerWidth);
            
                        // Size the input el to take up the maximum amount of remaining list width,
                        // or the entirety of list width to cause wrapping if too little space remains.
                        inputEl = owner.inputEl;
                        inputElCt = owner.inputElCt;
                        listBox = itemList.getBox(true, true);
                        listWidth = listBox.width;
            
                        if ((owner.grow && owner.growMax && (itemList.dom.scrollHeight > (owner.growMax - 25))) ||
                            (owner.isFixedHeight() && (itemList.dom.scrollHeight > itemList.dom.clientHeight))) {
                            listWidth = listWidth - Ext.getScrollbarSize().width;
                        }
                        inputWidth = listWidth - 10;
                        lastEntry = inputElCt.dom.previousSibling;
                        if (lastEntry) {
                            inputWidth = inputWidth - (lastEntry.offsetLeft + Ext.fly(lastEntry).getWidth() + Ext.fly(lastEntry).getPadding('lr'));
                        }
                        if (inputWidth < 35) {
                            inputWidth = listWidth - 10;
                        }
            
                        if (inputWidth >= 0) {
                            me.setElementSize(inputEl, inputWidth);
                            if (owner.hasFocus) {
                                inputElCt.scrollIntoView(itemList);
                            }
                        }
                    }
                }
            
            });            (function() {
                var Ext = window.Ext4 || window.Ext;
            
                /**
                 * ComboBox for choosing allowed values for the field of a model
                 *
                 *     @example
                 *     Ext.create('Ext.Container', {
                 *         items: [{
                 *             xtype: 'rallyattributecombobox',
                 *             model: 'UserStory',
                 *             field: 'ScheduleState'
                 *         }],
                 *         renderTo: Ext.getBody().dom
                 *     });
                 */
                Ext.define('Rally.ui.AttributeMultiComboBox', {
                    requires: ['Ext.Array'],
                    extend: 'Ext.ux.form.field.BoxSelect',
                    alias: 'widget.rallyattributemulticombobox',
            
                    config: {
                        /**
                         * @cfg {Ext.data.Model/String} model (required) The model containing the specified field used to populate the store.
                         * Not required if field is an instance of Ext.data.Field.
                         */
                        model: undefined,
            
                        /**
                         * @cfg {Ext.data.Field/String} field (required) The model's field, whose allowed values will be used to populate the store.
                         */
                        field: undefined,
            
                        /**
                         * @cfg {Object} context An object specifying the scoping settings for retrieving the specified model
                         * If not specified the values provided by {Rally.env.Environment#getContext} will be used.
                         */
                        context: undefined,
            
                        /**
                         * @cfg {Object} storeConfig A configuration object which will be passed to the underlying data store
                         */
                        storeConfig: undefined,
            
                        queryMode: 'local',
                        editable: false,
                        valueField: 'value',
                        displayField: 'name'
                    },
            
                    /**
                     * @constructor
                     */
                    constructor: function(config) {
            
                        this.mergeConfig(config);
            
                        this.store = Ext.create('Ext.data.Store', {
                            fields: [this.valueField, this.displayField],
                            data: []
                        });
            
                        return this.callParent(arguments);
                    },
            
                    initComponent: function() {
            
                        this.callParent(arguments);
            
                        if(this.storeConfig && this.storeConfig.listeners) {
                            this.store.on(this.storeConfig.listeners);
                        }
                        this.on('afterrender', this._onAfterRender, this);
            
                        if (Ext.isString(this.model)) {
                            this._fetchModel();
                        } else {
                            if (Ext.isString(this.field)) {
                                this.field = this.model.getField(this.field);
                            }
                            this._populateStore();
                        }
                    },
            
                    _fetchModel: function() {
                        Rally.data.ModelFactory.getModel({
                            context: this.context,
                            type: this.model,
                            success: this._onModelRetrieved,
                            scope: this
                        });
                    },
            
                    _onModelRetrieved: function(model) {
                        this.model = model;
                        this.field = this.model.getField(this.field);
                        this._populateStore();
                    },
            
                    _populateStore: function() {
                        if (!this.field) {
                            Ext.Error.raise('field config must be specified when creating a Rally.ui.AttributeComboBox');
                        }
                        var allowedValueObjects = this.field.allowedValues;
                        var allowedValues = [];
                        if (this.field.required === false) {
                            var name = "-- No Entry --";
                            var value = "";
                            if (this.field.attributeDefinition.AttributeType.toLowerCase() === 'rating') {
                                name = "None";
                                value = "None";
                            }
                            var allowedValue = {};
                            allowedValue[this.valueField] = value;
                            allowedValue[this.displayField] = name;
                            allowedValues.push(allowedValue);
                        }
                        Ext.each(allowedValueObjects, function(allowedValueObject) {
                            if (allowedValueObject.StringValue != "") {
                                var allowedValue = {};
                                allowedValue[this.valueField] = allowedValueObject.StringValue;
                                allowedValue[this.displayField] = allowedValueObject.StringValue;
                                allowedValues.push(allowedValue);
                            }
                        }, this);
                        this.store.loadRawData(allowedValues);
            			this.fireEvent('ready', this);
                    },
            
                    _onAfterRender: function() {
                        this._afterRender = true;
                        if(this._storeLoaded) {
                            this.fireEvent('ready', this);
                        }
                    },
            
                    onReady: function() {
                        this._storeLoaded = true;
                        if(this._afterRender) {
                            this.fireEvent('ready', this);
                        }
                    }
                });
            })();            /**
             * Version: 1.0 Alpha-1 
             * Build Date: 13-Nov-2007
             * Copyright (c) 2006-2007, Coolite Inc. (http://www.coolite.com/). All rights reserved.
             * License: Licensed under The MIT License. See license.txt and http://www.datejs.com/license/. 
             * Website: http://www.datejs.com/ or http://www.coolite.com/datejs/
             */
            Date.CultureInfo={name:"en-US",englishName:"English (United States)",nativeName:"English (United States)",dayNames:["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],abbreviatedDayNames:["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],shortestDayNames:["Su","Mo","Tu","We","Th","Fr","Sa"],firstLetterDayNames:["S","M","T","W","T","F","S"],monthNames:["January","February","March","April","May","June","July","August","September","October","November","December"],abbreviatedMonthNames:["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],amDesignator:"AM",pmDesignator:"PM",firstDayOfWeek:0,twoDigitYearMax:2029,dateElementOrder:"mdy",formatPatterns:{shortDate:"M/d/yyyy",longDate:"dddd, MMMM dd, yyyy",shortTime:"h:mm tt",longTime:"h:mm:ss tt",fullDateTime:"dddd, MMMM dd, yyyy h:mm:ss tt",sortableDateTime:"yyyy-MM-ddTHH:mm:ss",universalSortableDateTime:"yyyy-MM-dd HH:mm:ssZ",rfc1123:"ddd, dd MMM yyyy HH:mm:ss GMT",monthDay:"MMMM dd",yearMonth:"MMMM, yyyy"},regexPatterns:{jan:/^jan(uary)?/i,feb:/^feb(ruary)?/i,mar:/^mar(ch)?/i,apr:/^apr(il)?/i,may:/^may/i,jun:/^jun(e)?/i,jul:/^jul(y)?/i,aug:/^aug(ust)?/i,sep:/^sep(t(ember)?)?/i,oct:/^oct(ober)?/i,nov:/^nov(ember)?/i,dec:/^dec(ember)?/i,sun:/^su(n(day)?)?/i,mon:/^mo(n(day)?)?/i,tue:/^tu(e(s(day)?)?)?/i,wed:/^we(d(nesday)?)?/i,thu:/^th(u(r(s(day)?)?)?)?/i,fri:/^fr(i(day)?)?/i,sat:/^sa(t(urday)?)?/i,future:/^next/i,past:/^last|past|prev(ious)?/i,add:/^(|after|from)/i,subtract:/^(\-|before|ago)/i,yesterday:/^yesterday/i,today:/^t(oday)?/i,tomorrow:/^tomorrow/i,now:/^n(ow)?/i,millisecond:/^ms|milli(second)?s?/i,second:/^sec(ond)?s?/i,minute:/^min(ute)?s?/i,hour:/^h(ou)?rs?/i,week:/^w(ee)?k/i,month:/^m(o(nth)?s?)?/i,day:/^d(ays?)?/i,year:/^y((ea)?rs?)?/i,shortMeridian:/^(a|p)/i,longMeridian:/^(a\.?m?\.?|p\.?m?\.?)/i,timezone:/^((e(s|d)t|c(s|d)t|m(s|d)t|p(s|d)t)|((gmt)?\s*(|\-)\s*\d\d\d\d?)|gmt)/i,ordinalSuffix:/^\s*(st|nd|rd|th)/i,timeContext:/^\s*(\:|a|p)/i},abbreviatedTimeZoneStandard:{GMT:"-000",EST:"-0400",CST:"-0500",MST:"-0600",PST:"-0700"},abbreviatedTimeZoneDST:{GMT:"-000",EDT:"-0500",CDT:"-0600",MDT:"-0700",PDT:"-0800"}};
            Date.getMonthNumberFromName=function(name){var n=Date.CultureInfo.monthNames,m=Date.CultureInfo.abbreviatedMonthNames,s=name.toLowerCase();for(var i=0;i<n.length;i++){if(n[i].toLowerCase()==s||m[i].toLowerCase()==s){return i;}}
            return-1;};Date.getDayNumberFromName=function(name){var n=Date.CultureInfo.dayNames,m=Date.CultureInfo.abbreviatedDayNames,o=Date.CultureInfo.shortestDayNames,s=name.toLowerCase();for(var i=0;i<n.length;i++){if(n[i].toLowerCase()==s||m[i].toLowerCase()==s){return i;}}
            return-1;};Date.isLeapYear=function(year){return(((year%4===0)&&(year%100!==0))||(year%400===0));};Date.getDaysInMonth=function(year,month){return[31,(Date.isLeapYear(year)?29:28),31,30,31,30,31,31,30,31,30,31][month];};Date.getTimezoneOffset=function(s,dst){return(dst||false)?Date.CultureInfo.abbreviatedTimeZoneDST[s.toUpperCase()]:Date.CultureInfo.abbreviatedTimeZoneStandard[s.toUpperCase()];};Date.getTimezoneAbbreviation=function(offset,dst){var n=(dst||false)?Date.CultureInfo.abbreviatedTimeZoneDST:Date.CultureInfo.abbreviatedTimeZoneStandard,p;for(p in n){if(n[p]===offset){return p;}}
            return null;};Date.prototype.clone=function(){return new Date(this.getTime());};Date.prototype.compareTo=function(date){if(isNaN(this)){throw new Error(this);}
            if(date instanceof Date&&!isNaN(date)){return(this>date)?1:(this<date)?-1:0;}else{throw new TypeError(date);}};Date.prototype.equals=function(date){return(this.compareTo(date)===0);};Date.prototype.between=function(start,end){var t=this.getTime();return t>=start.getTime()&&t<=end.getTime();};Date.prototype.addMilliseconds=function(value){this.setMilliseconds(this.getMilliseconds()+value);return this;};Date.prototype.addSeconds=function(value){return this.addMilliseconds(value*1000);};Date.prototype.addMinutes=function(value){return this.addMilliseconds(value*60000);};Date.prototype.addHours=function(value){return this.addMilliseconds(value*3600000);};Date.prototype.addDays=function(value){return this.addMilliseconds(value*86400000);};Date.prototype.addWeeks=function(value){return this.addMilliseconds(value*604800000);};Date.prototype.addMonths=function(value){var n=this.getDate();this.setDate(1);this.setMonth(this.getMonth()+value);this.setDate(Math.min(n,this.getDaysInMonth()));return this;};Date.prototype.addYears=function(value){return this.addMonths(value*12);};Date.prototype.add=function(config){if(typeof config=="number"){this._orient=config;return this;}
            var x=config;if(x.millisecond||x.milliseconds){this.addMilliseconds(x.millisecond||x.milliseconds);}
            if(x.second||x.seconds){this.addSeconds(x.second||x.seconds);}
            if(x.minute||x.minutes){this.addMinutes(x.minute||x.minutes);}
            if(x.hour||x.hours){this.addHours(x.hour||x.hours);}
            if(x.month||x.months){this.addMonths(x.month||x.months);}
            if(x.year||x.years){this.addYears(x.year||x.years);}
            if(x.day||x.days){this.addDays(x.day||x.days);}
            return this;};Date._validate=function(value,min,max,name){if(typeof value!="number"){throw new TypeError(value+" is not a Number.");}else if(value<min||value>max){throw new RangeError(value+" is not a valid value for "+name+".");}
            return true;};Date.validateMillisecond=function(n){return Date._validate(n,0,999,"milliseconds");};Date.validateSecond=function(n){return Date._validate(n,0,59,"seconds");};Date.validateMinute=function(n){return Date._validate(n,0,59,"minutes");};Date.validateHour=function(n){return Date._validate(n,0,23,"hours");};Date.validateDay=function(n,year,month){return Date._validate(n,1,Date.getDaysInMonth(year,month),"days");};Date.validateMonth=function(n){return Date._validate(n,0,11,"months");};Date.validateYear=function(n){return Date._validate(n,1,9999,"seconds");};Date.prototype.set=function(config){var x=config;if(!x.millisecond&&x.millisecond!==0){x.millisecond=-1;}
            if(!x.second&&x.second!==0){x.second=-1;}
            if(!x.minute&&x.minute!==0){x.minute=-1;}
            if(!x.hour&&x.hour!==0){x.hour=-1;}
            if(!x.day&&x.day!==0){x.day=-1;}
            if(!x.month&&x.month!==0){x.month=-1;}
            if(!x.year&&x.year!==0){x.year=-1;}
            if(x.millisecond!=-1&&Date.validateMillisecond(x.millisecond)){this.addMilliseconds(x.millisecond-this.getMilliseconds());}
            if(x.second!=-1&&Date.validateSecond(x.second)){this.addSeconds(x.second-this.getSeconds());}
            if(x.minute!=-1&&Date.validateMinute(x.minute)){this.addMinutes(x.minute-this.getMinutes());}
            if(x.hour!=-1&&Date.validateHour(x.hour)){this.addHours(x.hour-this.getHours());}
            if(x.month!==-1&&Date.validateMonth(x.month)){this.addMonths(x.month-this.getMonth());}
            if(x.year!=-1&&Date.validateYear(x.year)){this.addYears(x.year-this.getFullYear());}
            if(x.day!=-1&&Date.validateDay(x.day,this.getFullYear(),this.getMonth())){this.addDays(x.day-this.getDate());}
            if(x.timezone){this.setTimezone(x.timezone);}
            if(x.timezoneOffset){this.setTimezoneOffset(x.timezoneOffset);}
            return this;};Date.prototype.clearTime=function(){this.setHours(0);this.setMinutes(0);this.setSeconds(0);this.setMilliseconds(0);return this;};Date.prototype.isLeapYear=function(){var y=this.getFullYear();return(((y%4===0)&&(y%100!==0))||(y%400===0));};Date.prototype.isWeekday=function(){return!(this.is().sat()||this.is().sun());};Date.prototype.getDaysInMonth=function(){return Date.getDaysInMonth(this.getFullYear(),this.getMonth());};Date.prototype.moveToFirstDayOfMonth=function(){return this.set({day:1});};Date.prototype.moveToLastDayOfMonth=function(){return this.set({day:this.getDaysInMonth()});};Date.prototype.moveToDayOfWeek=function(day,orient){var diff=(day-this.getDay()+7*(orient||+1))%7;return this.addDays((diff===0)?diff+=7*(orient||+1):diff);};Date.prototype.moveToMonth=function(month,orient){var diff=(month-this.getMonth()+12*(orient||+1))%12;return this.addMonths((diff===0)?diff+=12*(orient||+1):diff);};Date.prototype.getDayOfYear=function(){return Math.floor((this-new Date(this.getFullYear(),0,1))/86400000);};Date.prototype.getWeekOfYear=function(firstDayOfWeek){var y=this.getFullYear(),m=this.getMonth(),d=this.getDate();var dow=firstDayOfWeek||Date.CultureInfo.firstDayOfWeek;var offset=7+1-new Date(y,0,1).getDay();if(offset==8){offset=1;}
            var daynum=((Date.UTC(y,m,d,0,0,0)-Date.UTC(y,0,1,0,0,0))/86400000)+1;var w=Math.floor((daynum-offset+7)/7);if(w===dow){y--;var prevOffset=7+1-new Date(y,0,1).getDay();if(prevOffset==2||prevOffset==8){w=53;}else{w=52;}}
            return w;};Date.prototype.isDST=function(){console.log('isDST');return this.toString().match(/(E|C|M|P)(S|D)T/)[2]=="D";};Date.prototype.getTimezone=function(){return Date.getTimezoneAbbreviation(this.getUTCOffset,this.isDST());};Date.prototype.setTimezoneOffset=function(s){var here=this.getTimezoneOffset(),there=Number(s)*-6/10;this.addMinutes(there-here);return this;};Date.prototype.setTimezone=function(s){return this.setTimezoneOffset(Date.getTimezoneOffset(s));};Date.prototype.getUTCOffset=function(){var n=this.getTimezoneOffset()*-10/6,r;if(n<0){r=(n-10000).toString();return r[0]+r.substr(2);}else{r=(n+10000).toString();return"+"+r.substr(1);}};Date.prototype.getDayName=function(abbrev){return abbrev?Date.CultureInfo.abbreviatedDayNames[this.getDay()]:Date.CultureInfo.dayNames[this.getDay()];};Date.prototype.getMonthName=function(abbrev){return abbrev?Date.CultureInfo.abbreviatedMonthNames[this.getMonth()]:Date.CultureInfo.monthNames[this.getMonth()];};Date.prototype._toString=Date.prototype.toString;Date.prototype.toString=function(format){var self=this;var p=function p(s){return(s.toString().length==1)?"0"+s:s;};return format?format.replace(/dd?d?d?|MM?M?M?|yy?y?y?|hh?|HH?|mm?|ss?|tt?|zz?z?/g,function(format){switch(format){case"hh":return p(self.getHours()<13?self.getHours():(self.getHours()-12));case"h":return self.getHours()<13?self.getHours():(self.getHours()-12);case"HH":return p(self.getHours());case"H":return self.getHours();case"mm":return p(self.getMinutes());case"m":return self.getMinutes();case"ss":return p(self.getSeconds());case"s":return self.getSeconds();case"yyyy":return self.getFullYear();case"yy":return self.getFullYear().toString().substring(2,4);case"dddd":return self.getDayName();case"ddd":return self.getDayName(true);case"dd":return p(self.getDate());case"d":return self.getDate().toString();case"MMMM":return self.getMonthName();case"MMM":return self.getMonthName(true);case"MM":return p((self.getMonth()+1));case"M":return self.getMonth()+1;case"t":return self.getHours()<12?Date.CultureInfo.amDesignator.substring(0,1):Date.CultureInfo.pmDesignator.substring(0,1);case"tt":return self.getHours()<12?Date.CultureInfo.amDesignator:Date.CultureInfo.pmDesignator;case"zzz":case"zz":case"z":return"";}}):this._toString();};
            Date.now=function(){return new Date();};Date.today=function(){return Date.now().clearTime();};Date.prototype._orient=+1;Date.prototype.next=function(){this._orient=+1;return this;};Date.prototype.last=Date.prototype.prev=Date.prototype.previous=function(){this._orient=-1;return this;};Date.prototype._is=false;Date.prototype.is=function(){this._is=true;return this;};Number.prototype._dateElement="day";Number.prototype.fromNow=function(){var c={};c[this._dateElement]=this;return Date.now().add(c);};Number.prototype.ago=function(){var c={};c[this._dateElement]=this*-1;return Date.now().add(c);};(function(){var $D=Date.prototype,$N=Number.prototype;var dx=("sunday monday tuesday wednesday thursday friday saturday").split(/\s/),mx=("january february march april may june july august september october november december").split(/\s/),px=("Millisecond Second Minute Hour Day Week Month Year").split(/\s/),de;var df=function(n){return function(){if(this._is){this._is=false;return this.getDay()==n;}
            return this.moveToDayOfWeek(n,this._orient);};};for(var i=0;i<dx.length;i++){$D[dx[i]]=$D[dx[i].substring(0,3)]=df(i);}
            var mf=function(n){return function(){if(this._is){this._is=false;return this.getMonth()===n;}
            return this.moveToMonth(n,this._orient);};};for(var j=0;j<mx.length;j++){$D[mx[j]]=$D[mx[j].substring(0,3)]=mf(j);}
            var ef=function(j){return function(){if(j.substring(j.length-1)!="s"){j+="s";}
            return this["add"+j](this._orient);};};var nf=function(n){return function(){this._dateElement=n;return this;};};for(var k=0;k<px.length;k++){de=px[k].toLowerCase();$D[de]=$D[de+"s"]=ef(px[k]);$N[de]=$N[de+"s"]=nf(de);}}());Date.prototype.toJSONString=function(){return this.toString("yyyy-MM-ddThh:mm:ssZ");};Date.prototype.toShortDateString=function(){return this.toString(Date.CultureInfo.formatPatterns.shortDatePattern);};Date.prototype.toLongDateString=function(){return this.toString(Date.CultureInfo.formatPatterns.longDatePattern);};Date.prototype.toShortTimeString=function(){return this.toString(Date.CultureInfo.formatPatterns.shortTimePattern);};Date.prototype.toLongTimeString=function(){return this.toString(Date.CultureInfo.formatPatterns.longTimePattern);};Date.prototype.getOrdinal=function(){switch(this.getDate()){case 1:case 21:case 31:return"st";case 2:case 22:return"nd";case 3:case 23:return"rd";default:return"th";}};
            (function(){Date.Parsing={Exception:function(s){this.message="Parse error at '"+s.substring(0,10)+" ...'";}};var $P=Date.Parsing;var _=$P.Operators={rtoken:function(r){return function(s){var mx=s.match(r);if(mx){return([mx[0],s.substring(mx[0].length)]);}else{throw new $P.Exception(s);}};},token:function(s){return function(s){return _.rtoken(new RegExp("^\s*"+s+"\s*"))(s);};},stoken:function(s){return _.rtoken(new RegExp("^"+s));},until:function(p){return function(s){var qx=[],rx=null;while(s.length){try{rx=p.call(this,s);}catch(e){qx.push(rx[0]);s=rx[1];continue;}
            break;}
            return[qx,s];};},many:function(p){return function(s){var rx=[],r=null;while(s.length){try{r=p.call(this,s);}catch(e){return[rx,s];}
            rx.push(r[0]);s=r[1];}
            return[rx,s];};},optional:function(p){return function(s){var r=null;try{r=p.call(this,s);}catch(e){return[null,s];}
            return[r[0],r[1]];};},not:function(p){return function(s){try{p.call(this,s);}catch(e){return[null,s];}
            throw new $P.Exception(s);};},ignore:function(p){return p?function(s){var r=null;r=p.call(this,s);return[null,r[1]];}:null;},product:function(){var px=arguments[0],qx=Array.prototype.slice.call(arguments,1),rx=[];for(var i=0;i<px.length;i++){rx.push(_.each(px[i],qx));}
            return rx;},cache:function(rule){var cache={},r=null;return function(s){try{r=cache[s]=(cache[s]||rule.call(this,s));}catch(e){r=cache[s]=e;}
            if(r instanceof $P.Exception){throw r;}else{return r;}};},any:function(){var px=arguments;return function(s){var r=null;for(var i=0;i<px.length;i++){if(px[i]==null){continue;}
            try{r=(px[i].call(this,s));}catch(e){r=null;}
            if(r){return r;}}
            throw new $P.Exception(s);};},each:function(){var px=arguments;return function(s){var rx=[],r=null;for(var i=0;i<px.length;i++){if(px[i]==null){continue;}
            try{r=(px[i].call(this,s));}catch(e){throw new $P.Exception(s);}
            rx.push(r[0]);s=r[1];}
            return[rx,s];};},all:function(){var px=arguments,_=_;return _.each(_.optional(px));},sequence:function(px,d,c){d=d||_.rtoken(/^\s*/);c=c||null;if(px.length==1){return px[0];}
            return function(s){var r=null,q=null;var rx=[];for(var i=0;i<px.length;i++){try{r=px[i].call(this,s);}catch(e){break;}
            rx.push(r[0]);try{q=d.call(this,r[1]);}catch(ex){q=null;break;}
            s=q[1];}
            if(!r){throw new $P.Exception(s);}
            if(q){throw new $P.Exception(q[1]);}
            if(c){try{r=c.call(this,r[1]);}catch(ey){throw new $P.Exception(r[1]);}}
            return[rx,(r?r[1]:s)];};},between:function(d1,p,d2){d2=d2||d1;var _fn=_.each(_.ignore(d1),p,_.ignore(d2));return function(s){var rx=_fn.call(this,s);return[[rx[0][0],r[0][2]],rx[1]];};},list:function(p,d,c){d=d||_.rtoken(/^\s*/);c=c||null;return(p instanceof Array?_.each(_.product(p.slice(0,-1),_.ignore(d)),p.slice(-1),_.ignore(c)):_.each(_.many(_.each(p,_.ignore(d))),px,_.ignore(c)));},set:function(px,d,c){d=d||_.rtoken(/^\s*/);c=c||null;return function(s){var r=null,p=null,q=null,rx=null,best=[[],s],last=false;for(var i=0;i<px.length;i++){q=null;p=null;r=null;last=(px.length==1);try{r=px[i].call(this,s);}catch(e){continue;}
            rx=[[r[0]],r[1]];if(r[1].length>0&&!last){try{q=d.call(this,r[1]);}catch(ex){last=true;}}else{last=true;}
            if(!last&&q[1].length===0){last=true;}
            if(!last){var qx=[];for(var j=0;j<px.length;j++){if(i!=j){qx.push(px[j]);}}
            p=_.set(qx,d).call(this,q[1]);if(p[0].length>0){rx[0]=rx[0].concat(p[0]);rx[1]=p[1];}}
            if(rx[1].length<best[1].length){best=rx;}
            if(best[1].length===0){break;}}
            if(best[0].length===0){return best;}
            if(c){try{q=c.call(this,best[1]);}catch(ey){throw new $P.Exception(best[1]);}
            best[1]=q[1];}
            return best;};},forward:function(gr,fname){return function(s){return gr[fname].call(this,s);};},replace:function(rule,repl){return function(s){var r=rule.call(this,s);return[repl,r[1]];};},process:function(rule,fn){return function(s){var r=rule.call(this,s);return[fn.call(this,r[0]),r[1]];};},min:function(min,rule){return function(s){var rx=rule.call(this,s);if(rx[0].length<min){throw new $P.Exception(s);}
            return rx;};}};var _generator=function(op){return function(){var args=null,rx=[];if(arguments.length>1){args=Array.prototype.slice.call(arguments);}else if(arguments[0]instanceof Array){args=arguments[0];}
            if(args){for(var i=0,px=args.shift();i<px.length;i++){args.unshift(px[i]);rx.push(op.apply(null,args));args.shift();return rx;}}else{return op.apply(null,arguments);}};};var gx="optional not ignore cache".split(/\s/);for(var i=0;i<gx.length;i++){_[gx[i]]=_generator(_[gx[i]]);}
            var _vector=function(op){return function(){if(arguments[0]instanceof Array){return op.apply(null,arguments[0]);}else{return op.apply(null,arguments);}};};var vx="each any all".split(/\s/);for(var j=0;j<vx.length;j++){_[vx[j]]=_vector(_[vx[j]]);}}());(function(){var flattenAndCompact=function(ax){var rx=[];for(var i=0;i<ax.length;i++){if(ax[i]instanceof Array){rx=rx.concat(flattenAndCompact(ax[i]));}else{if(ax[i]){rx.push(ax[i]);}}}
            return rx;};Date.Grammar={};Date.Translator={hour:function(s){return function(){this.hour=Number(s);};},minute:function(s){return function(){this.minute=Number(s);};},second:function(s){return function(){this.second=Number(s);};},meridian:function(s){return function(){this.meridian=s.slice(0,1).toLowerCase();};},timezone:function(s){return function(){var n=s.replace(/[^\d\-]/g,"");if(n.length){this.timezoneOffset=Number(n);}else{this.timezone=s.toLowerCase();}};},day:function(x){var s=x[0];return function(){this.day=Number(s.match(/\d+/)[0]);};},month:function(s){return function(){this.month=((s.length==3)?Date.getMonthNumberFromName(s):(Number(s)-1));};},year:function(s){return function(){var n=Number(s);this.year=((s.length>2)?n:(n+(((n+2000)<Date.CultureInfo.twoDigitYearMax)?2000:1900)));};},rday:function(s){return function(){switch(s){case"yesterday":this.days=-1;break;case"tomorrow":this.days=1;break;case"today":this.days=0;break;case"now":this.days=0;this.now=true;break;}};},finishExact:function(x){x=(x instanceof Array)?x:[x];var now=new Date();this.year=now.getFullYear();this.month=now.getMonth();this.day=1;this.hour=0;this.minute=0;this.second=0;for(var i=0;i<x.length;i++){if(x[i]){x[i].call(this);}}
            this.hour=(this.meridian=="p"&&this.hour<13)?this.hour+12:this.hour;if(this.day>Date.getDaysInMonth(this.year,this.month)){throw new RangeError(this.day+" is not a valid value for days.");}
            var r=new Date(this.year,this.month,this.day,this.hour,this.minute,this.second);if(this.timezone){r.set({timezone:this.timezone});}else if(this.timezoneOffset){r.set({timezoneOffset:this.timezoneOffset});}
            return r;},finish:function(x){x=(x instanceof Array)?flattenAndCompact(x):[x];if(x.length===0){return null;}
            for(var i=0;i<x.length;i++){if(typeof x[i]=="function"){x[i].call(this);}}
            if(this.now){return new Date();}
            var today=Date.today();var method=null;var expression=!!(this.days!=null||this.orient||this.operator);if(expression){var gap,mod,orient;orient=((this.orient=="past"||this.operator=="subtract")?-1:1);if(this.weekday){this.unit="day";gap=(Date.getDayNumberFromName(this.weekday)-today.getDay());mod=7;this.days=gap?((gap+(orient*mod))%mod):(orient*mod);}
            if(this.month){this.unit="month";gap=(this.month-today.getMonth());mod=12;this.months=gap?((gap+(orient*mod))%mod):(orient*mod);this.month=null;}
            if(!this.unit){this.unit="day";}
            if(this[this.unit+"s"]==null||this.operator!=null){if(!this.value){this.value=1;}
            if(this.unit=="week"){this.unit="day";this.value=this.value*7;}
            this[this.unit+"s"]=this.value*orient;}
            return today.add(this);}else{if(this.meridian&&this.hour){this.hour=(this.hour<13&&this.meridian=="p")?this.hour+12:this.hour;}
            if(this.weekday&&!this.day){this.day=(today.addDays((Date.getDayNumberFromName(this.weekday)-today.getDay()))).getDate();}
            if(this.month&&!this.day){this.day=1;}
            return today.set(this);}}};var _=Date.Parsing.Operators,g=Date.Grammar,t=Date.Translator,_fn;g.datePartDelimiter=_.rtoken(/^([\s\-\.\,\/\x27]+)/);g.timePartDelimiter=_.stoken(":");g.whiteSpace=_.rtoken(/^\s*/);g.generalDelimiter=_.rtoken(/^(([\s\,]|at|on)+)/);var _C={};g.ctoken=function(keys){var fn=_C[keys];if(!fn){var c=Date.CultureInfo.regexPatterns;var kx=keys.split(/\s+/),px=[];for(var i=0;i<kx.length;i++){px.push(_.replace(_.rtoken(c[kx[i]]),kx[i]));}
            fn=_C[keys]=_.any.apply(null,px);}
            return fn;};g.ctoken2=function(key){return _.rtoken(Date.CultureInfo.regexPatterns[key]);};g.h=_.cache(_.process(_.rtoken(/^(0[0-9]|1[0-2]|[1-9])/),t.hour));g.hh=_.cache(_.process(_.rtoken(/^(0[0-9]|1[0-2])/),t.hour));g.H=_.cache(_.process(_.rtoken(/^([0-1][0-9]|2[0-3]|[0-9])/),t.hour));g.HH=_.cache(_.process(_.rtoken(/^([0-1][0-9]|2[0-3])/),t.hour));g.m=_.cache(_.process(_.rtoken(/^([0-5][0-9]|[0-9])/),t.minute));g.mm=_.cache(_.process(_.rtoken(/^[0-5][0-9]/),t.minute));g.s=_.cache(_.process(_.rtoken(/^([0-5][0-9]|[0-9])/),t.second));g.ss=_.cache(_.process(_.rtoken(/^[0-5][0-9]/),t.second));g.hms=_.cache(_.sequence([g.H,g.mm,g.ss],g.timePartDelimiter));g.t=_.cache(_.process(g.ctoken2("shortMeridian"),t.meridian));g.tt=_.cache(_.process(g.ctoken2("longMeridian"),t.meridian));g.z=_.cache(_.process(_.rtoken(/^(|\-)?\s*\d\d\d\d?/),t.timezone));g.zz=_.cache(_.process(_.rtoken(/^(|\-)\s*\d\d\d\d/),t.timezone));g.zzz=_.cache(_.process(g.ctoken2("timezone"),t.timezone));g.timeSuffix=_.each(_.ignore(g.whiteSpace),_.set([g.tt,g.zzz]));g.time=_.each(_.optional(_.ignore(_.stoken("T"))),g.hms,g.timeSuffix);g.d=_.cache(_.process(_.each(_.rtoken(/^([0-2]\d|3[0-1]|\d)/),_.optional(g.ctoken2("ordinalSuffix"))),t.day));g.dd=_.cache(_.process(_.each(_.rtoken(/^([0-2]\d|3[0-1])/),_.optional(g.ctoken2("ordinalSuffix"))),t.day));g.ddd=g.dddd=_.cache(_.process(g.ctoken("sun mon tue wed thu fri sat"),function(s){return function(){this.weekday=s;};}));g.M=_.cache(_.process(_.rtoken(/^(1[0-2]|0\d|\d)/),t.month));g.MM=_.cache(_.process(_.rtoken(/^(1[0-2]|0\d)/),t.month));g.MMM=g.MMMM=_.cache(_.process(g.ctoken("jan feb mar apr may jun jul aug sep oct nov dec"),t.month));g.y=_.cache(_.process(_.rtoken(/^(\d\d?)/),t.year));g.yy=_.cache(_.process(_.rtoken(/^(\d\d)/),t.year));g.yyy=_.cache(_.process(_.rtoken(/^(\d\d?\d?\d?)/),t.year));g.yyyy=_.cache(_.process(_.rtoken(/^(\d\d\d\d)/),t.year));_fn=function(){return _.each(_.any.apply(null,arguments),_.not(g.ctoken2("timeContext")));};g.day=_fn(g.d,g.dd);g.month=_fn(g.M,g.MMM);g.year=_fn(g.yyyy,g.yy);g.orientation=_.process(g.ctoken("past future"),function(s){return function(){this.orient=s;};});g.operator=_.process(g.ctoken("add subtract"),function(s){return function(){this.operator=s;};});g.rday=_.process(g.ctoken("yesterday tomorrow today now"),t.rday);g.unit=_.process(g.ctoken("minute hour day week month year"),function(s){return function(){this.unit=s;};});g.value=_.process(_.rtoken(/^\d\d?(st|nd|rd|th)?/),function(s){return function(){this.value=s.replace(/\D/g,"");};});g.expression=_.set([g.rday,g.operator,g.value,g.unit,g.orientation,g.ddd,g.MMM]);_fn=function(){return _.set(arguments,g.datePartDelimiter);};g.mdy=_fn(g.ddd,g.month,g.day,g.year);g.ymd=_fn(g.ddd,g.year,g.month,g.day);g.dmy=_fn(g.ddd,g.day,g.month,g.year);g.date=function(s){return((g[Date.CultureInfo.dateElementOrder]||g.mdy).call(this,s));};g.format=_.process(_.many(_.any(_.process(_.rtoken(/^(dd?d?d?|MM?M?M?|yy?y?y?|hh?|HH?|mm?|ss?|tt?|zz?z?)/),function(fmt){if(g[fmt]){return g[fmt];}else{throw Date.Parsing.Exception(fmt);}}),_.process(_.rtoken(/^[^dMyhHmstz]+/),function(s){return _.ignore(_.stoken(s));}))),function(rules){return _.process(_.each.apply(null,rules),t.finishExact);});var _F={};var _get=function(f){return _F[f]=(_F[f]||g.format(f)[0]);};g.formats=function(fx){if(fx instanceof Array){var rx=[];for(var i=0;i<fx.length;i++){rx.push(_get(fx[i]));}
            return _.any.apply(null,rx);}else{return _get(fx);}};g._formats=g.formats(["yyyy-MM-ddTHH:mm:ss","ddd, MMM dd, yyyy H:mm:ss tt","ddd MMM d yyyy HH:mm:ss zzz","d"]);g._start=_.process(_.set([g.date,g.time,g.expression],g.generalDelimiter,g.whiteSpace),t.finish);g.start=function(s){try{var r=g._formats.call({},s);if(r[1].length===0){return r;}}catch(e){}
            return g._start.call({},s);};}());Date._parse=Date.parse;Date.parse=function(s){var r=null;if(!s){return null;}
            try{r=Date.Grammar.start.call({},s);}catch(e){return null;}
            return((r[1].length===0)?r[0]:null);};Date.getParseFunction=function(fx){var fn=Date.Grammar.formats(fx);return function(s){var r=null;try{r=fn.call({},s);}catch(e){return null;}
            return((r[1].length===0)?r[0]:null);};};Date.parseExact=function(s,fx){return Date.getParseFunction(fx)(s);};
            //     Underscore.js 1.3.3
            //     (c) 2009-2012 Jeremy Ashkenas, DocumentCloud Inc.
            //     Underscore is freely distributable under the MIT license.
            //     Portions of Underscore are inspired or borrowed from Prototype,
            //     Oliver Steele's Functional, and John Resig's Micro-Templating.
            //     For all details and documentation:
            //     http://documentcloud.github.com/underscore
            
            (function() {
            
              // Baseline setup
              // --------------
            
              // Establish the root object, `window` in the browser, or `global` on the server.
              var root = this;
            
              // Save the previous value of the `_` variable.
              var previousUnderscore = root._;
            
              // Establish the object that gets returned to break out of a loop iteration.
              var breaker = {};
            
              // Save bytes in the minified (but not gzipped) version:
              var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;
            
              // Create quick reference variables for speed access to core prototypes.
              var slice            = ArrayProto.slice,
                  unshift          = ArrayProto.unshift,
                  toString         = ObjProto.toString,
                  hasOwnProperty   = ObjProto.hasOwnProperty;
            
              // All **ECMAScript 5** native function implementations that we hope to use
              // are declared here.
              var
                nativeForEach      = ArrayProto.forEach,
                nativeMap          = ArrayProto.map,
                nativeReduce       = ArrayProto.reduce,
                nativeReduceRight  = ArrayProto.reduceRight,
                nativeFilter       = ArrayProto.filter,
                nativeEvery        = ArrayProto.every,
                nativeSome         = ArrayProto.some,
                nativeIndexOf      = ArrayProto.indexOf,
                nativeLastIndexOf  = ArrayProto.lastIndexOf,
                nativeIsArray      = Array.isArray,
                nativeKeys         = Object.keys,
                nativeBind         = FuncProto.bind;
            
              // Create a safe reference to the Underscore object for use below.
              var _ = function(obj) { return new wrapper(obj); };
            
              // Export the Underscore object for **Node.js**, with
              // backwards-compatibility for the old `require()` API. If we're in
              // the browser, add `_` as a global object via a string identifier,
              // for Closure Compiler "advanced" mode.
              if (typeof exports !== 'undefined') {
                if (typeof module !== 'undefined' && module.exports) {
                  exports = module.exports = _;
                }
                exports._ = _;
              } else {
                root['_'] = _;
              }
            
              // Current version.
              _.VERSION = '1.3.3';
            
              // Collection Functions
              // --------------------
            
              // The cornerstone, an `each` implementation, aka `forEach`.
              // Handles objects with the built-in `forEach`, arrays, and raw objects.
              // Delegates to **ECMAScript 5**'s native `forEach` if available.
              var each = _.each = _.forEach = function(obj, iterator, context) {
                if (obj == null) return;
                if (nativeForEach && obj.forEach === nativeForEach) {
                  obj.forEach(iterator, context);
                } else if (obj.length === +obj.length) {
                  for (var i = 0, l = obj.length; i < l; i++) {
                    if (i in obj && iterator.call(context, obj[i], i, obj) === breaker) return;
                  }
                } else {
                  for (var key in obj) {
                    if (_.has(obj, key)) {
                      if (iterator.call(context, obj[key], key, obj) === breaker) return;
                    }
                  }
                }
              };
            
              // Return the results of applying the iterator to each element.
              // Delegates to **ECMAScript 5**'s native `map` if available.
              _.map = _.collect = function(obj, iterator, context) {
                var results = [];
                if (obj == null) return results;
                if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);
                each(obj, function(value, index, list) {
                  results[results.length] = iterator.call(context, value, index, list);
                });
                if (obj.length === +obj.length) results.length = obj.length;
                return results;
              };
            
              // **Reduce** builds up a single result from a list of values, aka `inject`,
              // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.
              _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {
                var initial = arguments.length > 2;
                if (obj == null) obj = [];
                if (nativeReduce && obj.reduce === nativeReduce) {
                  if (context) iterator = _.bind(iterator, context);
                  return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);
                }
                each(obj, function(value, index, list) {
                  if (!initial) {
                    memo = value;
                    initial = true;
                  } else {
                    memo = iterator.call(context, memo, value, index, list);
                  }
                });
                if (!initial) throw new TypeError('Reduce of empty array with no initial value');
                return memo;
              };
            
              // The right-associative version of reduce, also known as `foldr`.
              // Delegates to **ECMAScript 5**'s native `reduceRight` if available.
              _.reduceRight = _.foldr = function(obj, iterator, memo, context) {
                var initial = arguments.length > 2;
                if (obj == null) obj = [];
                if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {
                  if (context) iterator = _.bind(iterator, context);
                  return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);
                }
                var reversed = _.toArray(obj).reverse();
                if (context && !initial) iterator = _.bind(iterator, context);
                return initial ? _.reduce(reversed, iterator, memo, context) : _.reduce(reversed, iterator);
              };
            
              // Return the first value which passes a truth test. Aliased as `detect`.
              _.find = _.detect = function(obj, iterator, context) {
                var result;
                any(obj, function(value, index, list) {
                  if (iterator.call(context, value, index, list)) {
                    result = value;
                    return true;
                  }
                });
                return result;
              };
            
              // Return all the elements that pass a truth test.
              // Delegates to **ECMAScript 5**'s native `filter` if available.
              // Aliased as `select`.
              _.filter = _.select = function(obj, iterator, context) {
                var results = [];
                if (obj == null) return results;
                if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);
                each(obj, function(value, index, list) {
                  if (iterator.call(context, value, index, list)) results[results.length] = value;
                });
                return results;
              };
            
              // Return all the elements for which a truth test fails.
              _.reject = function(obj, iterator, context) {
                var results = [];
                if (obj == null) return results;
                each(obj, function(value, index, list) {
                  if (!iterator.call(context, value, index, list)) results[results.length] = value;
                });
                return results;
              };
            
              // Determine whether all of the elements match a truth test.
              // Delegates to **ECMAScript 5**'s native `every` if available.
              // Aliased as `all`.
              _.every = _.all = function(obj, iterator, context) {
                var result = true;
                if (obj == null) return result;
                if (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);
                each(obj, function(value, index, list) {
                  if (!(result = result && iterator.call(context, value, index, list))) return breaker;
                });
                return !!result;
              };
            
              // Determine if at least one element in the object matches a truth test.
              // Delegates to **ECMAScript 5**'s native `some` if available.
              // Aliased as `any`.
              var any = _.some = _.any = function(obj, iterator, context) {
                iterator || (iterator = _.identity);
                var result = false;
                if (obj == null) return result;
                if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);
                each(obj, function(value, index, list) {
                  if (result || (result = iterator.call(context, value, index, list))) return breaker;
                });
                return !!result;
              };
            
              // Determine if a given value is included in the array or object using `===`.
              // Aliased as `contains`.
              _.include = _.contains = function(obj, target) {
                var found = false;
                if (obj == null) return found;
                if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;
                found = any(obj, function(value) {
                  return value === target;
                });
                return found;
              };
            
              // Invoke a method (with arguments) on every item in a collection.
              _.invoke = function(obj, method) {
                var args = slice.call(arguments, 2);
                return _.map(obj, function(value) {
                  return (_.isFunction(method) ? method || value : value[method]).apply(value, args);
                });
              };
            
              // Convenience version of a common use case of `map`: fetching a property.
              _.pluck = function(obj, key) {
                return _.map(obj, function(value){ return value[key]; });
              };
            
              // Return the maximum element or (element-based computation).
              _.max = function(obj, iterator, context) {
                if (!iterator && _.isArray(obj) && obj[0] === +obj[0]) return Math.max.apply(Math, obj);
                if (!iterator && _.isEmpty(obj)) return -Infinity;
                var result = {computed : -Infinity};
                each(obj, function(value, index, list) {
                  var computed = iterator ? iterator.call(context, value, index, list) : value;
                  computed >= result.computed && (result = {value : value, computed : computed});
                });
                return result.value;
              };
            
              // Return the minimum element (or element-based computation).
              _.min = function(obj, iterator, context) {
                if (!iterator && _.isArray(obj) && obj[0] === +obj[0]) return Math.min.apply(Math, obj);
                if (!iterator && _.isEmpty(obj)) return Infinity;
                var result = {computed : Infinity};
                each(obj, function(value, index, list) {
                  var computed = iterator ? iterator.call(context, value, index, list) : value;
                  computed < result.computed && (result = {value : value, computed : computed});
                });
                return result.value;
              };
            
              // Shuffle an array.
              _.shuffle = function(obj) {
                var shuffled = [], rand;
                each(obj, function(value, index, list) {
                  rand = Math.floor(Math.random() * (index + 1));
                  shuffled[index] = shuffled[rand];
                  shuffled[rand] = value;
                });
                return shuffled;
              };
            
              // Sort the object's values by a criterion produced by an iterator.
              _.sortBy = function(obj, val, context) {
                var iterator = _.isFunction(val) ? val : function(obj) { return obj[val]; };
                return _.pluck(_.map(obj, function(value, index, list) {
                  return {
                    value : value,
                    criteria : iterator.call(context, value, index, list)
                  };
                }).sort(function(left, right) {
                  var a = left.criteria, b = right.criteria;
                  if (a === void 0) return 1;
                  if (b === void 0) return -1;
                  return a < b ? -1 : a > b ? 1 : 0;
                }), 'value');
              };
            
              // Groups the object's values by a criterion. Pass either a string attribute
              // to group by, or a function that returns the criterion.
              _.groupBy = function(obj, val) {
                var result = {};
                var iterator = _.isFunction(val) ? val : function(obj) { return obj[val]; };
                each(obj, function(value, index) {
                  var key = iterator(value, index);
                  (result[key] || (result[key] = [])).push(value);
                });
                return result;
              };
            
              // Use a comparator function to figure out at what index an object should
              // be inserted so as to maintain order. Uses binary search.
              _.sortedIndex = function(array, obj, iterator) {
                iterator || (iterator = _.identity);
                var low = 0, high = array.length;
                while (low < high) {
                  var mid = (low + high) >> 1;
                  iterator(array[mid]) < iterator(obj) ? low = mid + 1 : high = mid;
                }
                return low;
              };
            
              // Safely convert anything iterable into a real, live array.
              _.toArray = function(obj) {
                if (!obj)                                     return [];
                if (_.isArray(obj))                           return slice.call(obj);
                if (_.isArguments(obj))                       return slice.call(obj);
                if (obj.toArray && _.isFunction(obj.toArray)) return obj.toArray();
                return _.values(obj);
              };
            
              // Return the number of elements in an object.
              _.size = function(obj) {
                return _.isArray(obj) ? obj.length : _.keys(obj).length;
              };
            
              // Array Functions
              // ---------------
            
              // Get the first element of an array. Passing **n** will return the first N
              // values in the array. Aliased as `head` and `take`. The **guard** check
              // allows it to work with `_.map`.
              _.first = _.head = _.take = function(array, n, guard) {
                return (n != null) && !guard ? slice.call(array, 0, n) : array[0];
              };
            
              // Returns everything but the last entry of the array. Especcialy useful on
              // the arguments object. Passing **n** will return all the values in
              // the array, excluding the last N. The **guard** check allows it to work with
              // `_.map`.
              _.initial = function(array, n, guard) {
                return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));
              };
            
              // Get the last element of an array. Passing **n** will return the last N
              // values in the array. The **guard** check allows it to work with `_.map`.
              _.last = function(array, n, guard) {
                if ((n != null) && !guard) {
                  return slice.call(array, Math.max(array.length - n, 0));
                } else {
                  return array[array.length - 1];
                }
              };
            
              // Returns everything but the first entry of the array. Aliased as `tail`.
              // Especially useful on the arguments object. Passing an **index** will return
              // the rest of the values in the array from that index onward. The **guard**
              // check allows it to work with `_.map`.
              _.rest = _.tail = function(array, index, guard) {
                return slice.call(array, (index == null) || guard ? 1 : index);
              };
            
              // Trim out all falsy values from an array.
              _.compact = function(array) {
                return _.filter(array, function(value){ return !!value; });
              };
            
              // Return a completely flattened version of an array.
              _.flatten = function(array, shallow) {
                return _.reduce(array, function(memo, value) {
                  if (_.isArray(value)) return memo.concat(shallow ? value : _.flatten(value));
                  memo[memo.length] = value;
                  return memo;
                }, []);
              };
            
              // Return a version of the array that does not contain the specified value(s).
              _.without = function(array) {
                return _.difference(array, slice.call(arguments, 1));
              };
            
              // Produce a duplicate-free version of the array. If the array has already
              // been sorted, you have the option of using a faster algorithm.
              // Aliased as `unique`.
              _.uniq = _.unique = function(array, isSorted, iterator) {
                var initial = iterator ? _.map(array, iterator) : array;
                var results = [];
                // The `isSorted` flag is irrelevant if the array only contains two elements.
                if (array.length < 3) isSorted = true;
                _.reduce(initial, function (memo, value, index) {
                  if (isSorted ? _.last(memo) !== value || !memo.length : !_.include(memo, value)) {
                    memo.push(value);
                    results.push(array[index]);
                  }
                  return memo;
                }, []);
                return results;
              };
            
              // Produce an array that contains the union: each distinct element from all of
              // the passed-in arrays.
              _.union = function() {
                return _.uniq(_.flatten(arguments, true));
              };
            
              // Produce an array that contains every item shared between all the
              // passed-in arrays. (Aliased as "intersect" for back-compat.)
              _.intersection = _.intersect = function(array) {
                var rest = slice.call(arguments, 1);
                return _.filter(_.uniq(array), function(item) {
                  return _.every(rest, function(other) {
                    return _.indexOf(other, item) >= 0;
                  });
                });
              };
            
              // Take the difference between one array and a number of other arrays.
              // Only the elements present in just the first array will remain.
              _.difference = function(array) {
                var rest = _.flatten(slice.call(arguments, 1), true);
                return _.filter(array, function(value){ return !_.include(rest, value); });
              };
            
              // Zip together multiple lists into a single array -- elements that share
              // an index go together.
              _.zip = function() {
                var args = slice.call(arguments);
                var length = _.max(_.pluck(args, 'length'));
                var results = new Array(length);
                for (var i = 0; i < length; i++) results[i] = _.pluck(args, "" + i);
                return results;
              };
            
              // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),
              // we need this function. Return the position of the first occurrence of an
              // item in an array, or -1 if the item is not included in the array.
              // Delegates to **ECMAScript 5**'s native `indexOf` if available.
              // If the array is large and already in sort order, pass `true`
              // for **isSorted** to use binary search.
              _.indexOf = function(array, item, isSorted) {
                if (array == null) return -1;
                var i, l;
                if (isSorted) {
                  i = _.sortedIndex(array, item);
                  return array[i] === item ? i : -1;
                }
                if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item);
                for (i = 0, l = array.length; i < l; i++) if (i in array && array[i] === item) return i;
                return -1;
              };
            
              // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.
              _.lastIndexOf = function(array, item) {
                if (array == null) return -1;
                if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) return array.lastIndexOf(item);
                var i = array.length;
                while (i--) if (i in array && array[i] === item) return i;
                return -1;
              };
            
              // Generate an integer Array containing an arithmetic progression. A port of
              // the native Python `range()` function. See
              // [the Python documentation](http://docs.python.org/library/functions.html#range).
              _.range = function(start, stop, step) {
                if (arguments.length <= 1) {
                  stop = start || 0;
                  start = 0;
                }
                step = arguments[2] || 1;
            
                var len = Math.max(Math.ceil((stop - start) / step), 0);
                var idx = 0;
                var range = new Array(len);
            
                while(idx < len) {
                  range[idx++] = start;
                  start += step;
                }
            
                return range;
              };
            
              // Function (ahem) Functions
              // ------------------
            
              // Reusable constructor function for prototype setting.
              var ctor = function(){};
            
              // Create a function bound to a given object (assigning `this`, and arguments,
              // optionally). Binding with arguments is also known as `curry`.
              // Delegates to **ECMAScript 5**'s native `Function.bind` if available.
              // We check for `func.bind` first, to fail fast when `func` is undefined.
              _.bind = function bind(func, context) {
                var bound, args;
                if (func.bind === nativeBind && nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
                if (!_.isFunction(func)) throw new TypeError;
                args = slice.call(arguments, 2);
                return bound = function() {
                  if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));
                  ctor.prototype = func.prototype;
                  var self = new ctor;
                  var result = func.apply(self, args.concat(slice.call(arguments)));
                  if (Object(result) === result) return result;
                  return self;
                };
              };
            
              // Bind all of an object's methods to that object. Useful for ensuring that
              // all callbacks defined on an object belong to it.
              _.bindAll = function(obj) {
                var funcs = slice.call(arguments, 1);
                if (funcs.length == 0) funcs = _.functions(obj);
                each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });
                return obj;
              };
            
              // Memoize an expensive function by storing its results.
              _.memoize = function(func, hasher) {
                var memo = {};
                hasher || (hasher = _.identity);
                return function() {
                  var key = hasher.apply(this, arguments);
                  return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));
                };
              };
            
              // Delays a function for the given number of milliseconds, and then calls
              // it with the arguments supplied.
              _.delay = function(func, wait) {
                var args = slice.call(arguments, 2);
                return setTimeout(function(){ return func.apply(null, args); }, wait);
              };
            
              // Defers a function, scheduling it to run after the current call stack has
              // cleared.
              _.defer = function(func) {
                return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));
              };
            
              // Returns a function, that, when invoked, will only be triggered at most once
              // during a given window of time.
              _.throttle = function(func, wait) {
                var context, args, timeout, throttling, more, result;
                var whenDone = _.debounce(function(){ more = throttling = false; }, wait);
                return function() {
                  context = this; args = arguments;
                  var later = function() {
                    timeout = null;
                    if (more) func.apply(context, args);
                    whenDone();
                  };
                  if (!timeout) timeout = setTimeout(later, wait);
                  if (throttling) {
                    more = true;
                  } else {
                    result = func.apply(context, args);
                  }
                  whenDone();
                  throttling = true;
                  return result;
                };
              };
            
              // Returns a function, that, as long as it continues to be invoked, will not
              // be triggered. The function will be called after it stops being called for
              // N milliseconds. If `immediate` is passed, trigger the function on the
              // leading edge, instead of the trailing.
              _.debounce = function(func, wait, immediate) {
                var timeout;
                return function() {
                  var context = this, args = arguments;
                  var later = function() {
                    timeout = null;
                    if (!immediate) func.apply(context, args);
                  };
                  if (immediate && !timeout) func.apply(context, args);
                  clearTimeout(timeout);
                  timeout = setTimeout(later, wait);
                };
              };
            
              // Returns a function that will be executed at most one time, no matter how
              // often you call it. Useful for lazy initialization.
              _.once = function(func) {
                var ran = false, memo;
                return function() {
                  if (ran) return memo;
                  ran = true;
                  return memo = func.apply(this, arguments);
                };
              };
            
              // Returns the first function passed as an argument to the second,
              // allowing you to adjust arguments, run code before and after, and
              // conditionally execute the original function.
              _.wrap = function(func, wrapper) {
                return function() {
                  var args = [func].concat(slice.call(arguments, 0));
                  return wrapper.apply(this, args);
                };
              };
            
              // Returns a function that is the composition of a list of functions, each
              // consuming the return value of the function that follows.
              _.compose = function() {
                var funcs = arguments;
                return function() {
                  var args = arguments;
                  for (var i = funcs.length - 1; i >= 0; i--) {
                    args = [funcs[i].apply(this, args)];
                  }
                  return args[0];
                };
              };
            
              // Returns a function that will only be executed after being called N times.
              _.after = function(times, func) {
                if (times <= 0) return func();
                return function() {
                  if (--times < 1) { return func.apply(this, arguments); }
                };
              };
            
              // Object Functions
              // ----------------
            
              // Retrieve the names of an object's properties.
              // Delegates to **ECMAScript 5**'s native `Object.keys`
              _.keys = nativeKeys || function(obj) {
                if (obj !== Object(obj)) throw new TypeError('Invalid object');
                var keys = [];
                for (var key in obj) if (_.has(obj, key)) keys[keys.length] = key;
                return keys;
              };
            
              // Retrieve the values of an object's properties.
              _.values = function(obj) {
                return _.map(obj, _.identity);
              };
            
              // Return a sorted list of the function names available on the object.
              // Aliased as `methods`
              _.functions = _.methods = function(obj) {
                var names = [];
                for (var key in obj) {
                  if (_.isFunction(obj[key])) names.push(key);
                }
                return names.sort();
              };
            
              // Extend a given object with all the properties in passed-in object(s).
              _.extend = function(obj) {
                each(slice.call(arguments, 1), function(source) {
                  for (var prop in source) {
                    obj[prop] = source[prop];
                  }
                });
                return obj;
              };
            
              // Return a copy of the object only containing the whitelisted properties.
              _.pick = function(obj) {
                var result = {};
                each(_.flatten(slice.call(arguments, 1)), function(key) {
                  if (key in obj) result[key] = obj[key];
                });
                return result;
              };
            
              // Fill in a given object with default properties.
              _.defaults = function(obj) {
                each(slice.call(arguments, 1), function(source) {
                  for (var prop in source) {
                    if (obj[prop] == null) obj[prop] = source[prop];
                  }
                });
                return obj;
              };
            
              // Create a (shallow-cloned) duplicate of an object.
              _.clone = function(obj) {
                if (!_.isObject(obj)) return obj;
                return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
              };
            
              // Invokes interceptor with the obj, and then returns obj.
              // The primary purpose of this method is to "tap into" a method chain, in
              // order to perform operations on intermediate results within the chain.
              _.tap = function(obj, interceptor) {
                interceptor(obj);
                return obj;
              };
            
              // Internal recursive comparison function.
              function eq(a, b, stack) {
                // Identical objects are equal. `0 === -0`, but they aren't identical.
                // See the Harmony `egal` proposal: http://wiki.ecmascript.org/doku.php?id=harmony:egal.
                if (a === b) return a !== 0 || 1 / a == 1 / b;
                // A strict comparison is necessary because `null == undefined`.
                if (a == null || b == null) return a === b;
                // Unwrap any wrapped objects.
                if (a._chain) a = a._wrapped;
                if (b._chain) b = b._wrapped;
                // Invoke a custom `isEqual` method if one is provided.
                if (a.isEqual && _.isFunction(a.isEqual)) return a.isEqual(b);
                if (b.isEqual && _.isFunction(b.isEqual)) return b.isEqual(a);
                // Compare `[[Class]]` names.
                var className = toString.call(a);
                if (className != toString.call(b)) return false;
                switch (className) {
                  // Strings, numbers, dates, and booleans are compared by value.
                  case '[object String]':
                    // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
                    // equivalent to `new String("5")`.
                    return a == String(b);
                  case '[object Number]':
                    // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for
                    // other numeric values.
                    return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);
                  case '[object Date]':
                  case '[object Boolean]':
                    // Coerce dates and booleans to numeric primitive values. Dates are compared by their
                    // millisecond representations. Note that invalid dates with millisecond representations
                    // of `NaN` are not equivalent.
                    return +a == +b;
                  // RegExps are compared by their source patterns and flags.
                  case '[object RegExp]':
                    return a.source == b.source &&
                           a.global == b.global &&
                           a.multiline == b.multiline &&
                           a.ignoreCase == b.ignoreCase;
                }
                if (typeof a != 'object' || typeof b != 'object') return false;
                // Assume equality for cyclic structures. The algorithm for detecting cyclic
                // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
                var length = stack.length;
                while (length--) {
                  // Linear search. Performance is inversely proportional to the number of
                  // unique nested structures.
                  if (stack[length] == a) return true;
                }
                // Add the first object to the stack of traversed objects.
                stack.push(a);
                var size = 0, result = true;
                // Recursively compare objects and arrays.
                if (className == '[object Array]') {
                  // Compare array lengths to determine if a deep comparison is necessary.
                  size = a.length;
                  result = size == b.length;
                  if (result) {
                    // Deep compare the contents, ignoring non-numeric properties.
                    while (size--) {
                      // Ensure commutative equality for sparse arrays.
                      if (!(result = size in a == size in b && eq(a[size], b[size], stack))) break;
                    }
                  }
                } else {
                  // Objects with different constructors are not equivalent.
                  if ('constructor' in a != 'constructor' in b || a.constructor != b.constructor) return false;
                  // Deep compare objects.
                  for (var key in a) {
                    if (_.has(a, key)) {
                      // Count the expected number of properties.
                      size++;
                      // Deep compare each member.
                      if (!(result = _.has(b, key) && eq(a[key], b[key], stack))) break;
                    }
                  }
                  // Ensure that both objects contain the same number of properties.
                  if (result) {
                    for (key in b) {
                      if (_.has(b, key) && !(size--)) break;
                    }
                    result = !size;
                  }
                }
                // Remove the first object from the stack of traversed objects.
                stack.pop();
                return result;
              }
            
              // Perform a deep comparison to check if two objects are equal.
              _.isEqual = function(a, b) {
                return eq(a, b, []);
              };
            
              // Is a given array, string, or object empty?
              // An "empty" object has no enumerable own-properties.
              _.isEmpty = function(obj) {
                if (obj == null) return true;
                if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;
                for (var key in obj) if (_.has(obj, key)) return false;
                return true;
              };
            
              // Is a given value a DOM element?
              _.isElement = function(obj) {
                return !!(obj && obj.nodeType == 1);
              };
            
              // Is a given value an array?
              // Delegates to ECMA5's native Array.isArray
              _.isArray = nativeIsArray || function(obj) {
                return toString.call(obj) == '[object Array]';
              };
            
              // Is a given variable an object?
              _.isObject = function(obj) {
                return obj === Object(obj);
              };
            
              // Is a given variable an arguments object?
              _.isArguments = function(obj) {
                return toString.call(obj) == '[object Arguments]';
              };
              if (!_.isArguments(arguments)) {
                _.isArguments = function(obj) {
                  return !!(obj && _.has(obj, 'callee'));
                };
              }
            
              // Is a given value a function?
              _.isFunction = function(obj) {
                return toString.call(obj) == '[object Function]';
              };
            
              // Is a given value a string?
              _.isString = function(obj) {
                return toString.call(obj) == '[object String]';
              };
            
              // Is a given value a number?
              _.isNumber = function(obj) {
                return toString.call(obj) == '[object Number]';
              };
            
              // Is a given object a finite number?
              _.isFinite = function(obj) {
                return _.isNumber(obj) && isFinite(obj);
              };
            
              // Is the given value `NaN`?
              _.isNaN = function(obj) {
                // `NaN` is the only value for which `===` is not reflexive.
                return obj !== obj;
              };
            
              // Is a given value a boolean?
              _.isBoolean = function(obj) {
                return obj === true || obj === false || toString.call(obj) == '[object Boolean]';
              };
            
              // Is a given value a date?
              _.isDate = function(obj) {
                return toString.call(obj) == '[object Date]';
              };
            
              // Is the given value a regular expression?
              _.isRegExp = function(obj) {
                return toString.call(obj) == '[object RegExp]';
              };
            
              // Is a given value equal to null?
              _.isNull = function(obj) {
                return obj === null;
              };
            
              // Is a given variable undefined?
              _.isUndefined = function(obj) {
                return obj === void 0;
              };
            
              // Has own property?
              _.has = function(obj, key) {
                return hasOwnProperty.call(obj, key);
              };
            
              // Utility Functions
              // -----------------
            
              // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
              // previous owner. Returns a reference to the Underscore object.
              _.noConflict = function() {
                root._ = previousUnderscore;
                return this;
              };
            
              // Keep the identity function around for default iterators.
              _.identity = function(value) {
                return value;
              };
            
              // Run a function **n** times.
              _.times = function (n, iterator, context) {
                for (var i = 0; i < n; i++) iterator.call(context, i);
              };
            
              // Escape a string for HTML interpolation.
              _.escape = function(string) {
                return (''+string).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#x27;').replace(/\//g,'&#x2F;');
              };
            
              // If the value of the named property is a function then invoke it;
              // otherwise, return it.
              _.result = function(object, property) {
                if (object == null) return null;
                var value = object[property];
                return _.isFunction(value) ? value.call(object) : value;
              };
            
              // Add your own custom functions to the Underscore object, ensuring that
              // they're correctly added to the OOP wrapper as well.
              _.mixin = function(obj) {
                each(_.functions(obj), function(name){
                  addToWrapper(name, _[name] = obj[name]);
                });
              };
            
              // Generate a unique integer id (unique within the entire client session).
              // Useful for temporary DOM ids.
              var idCounter = 0;
              _.uniqueId = function(prefix) {
                var id = idCounter++;
                return prefix ? prefix + id : id;
              };
            
              // By default, Underscore uses ERB-style template delimiters, change the
              // following template settings to use alternative delimiters.
              _.templateSettings = {
                evaluate    : /<%([\s\S]+?)%>/g,
                interpolate : /<%=([\s\S]+?)%>/g,
                escape      : /<%-([\s\S]+?)%>/g
              };
            
              // When customizing `templateSettings`, if you don't want to define an
              // interpolation, evaluation or escaping regex, we need one that is
              // guaranteed not to match.
              var noMatch = /.^/;
            
              // Certain characters need to be escaped so that they can be put into a
              // string literal.
              var escapes = {
                "'": "'",
                'r': '\r',
                'n': '\n',
                't': '\t',
                'u2028': '\u2028',
                'u2029': '\u2029'
              };
            
              for (var p in escapes) escapes[escapes[p]] = p;
              var escaper = /'|\r|\n|\t|\u2028|\u2029/g;
              var unescaper = /('|r|n|t|u2028|u2029)/g;
            
              // Within an interpolation, evaluation, or escaping, remove HTML escaping
              // that had been previously added.
              var unescape = function(code) {
                return code.replace(unescaper, function(match, escape) {
                  return escapes[escape];
                });
              };
            
              // JavaScript micro-templating, similar to John Resig's implementation.
              // Underscore templating handles arbitrary delimiters, preserves whitespace,
              // and correctly escapes quotes within interpolated code.
              _.template = function(text, data, settings) {
                settings = _.defaults(settings || {}, _.templateSettings);
            
                // Compile the template source, taking care to escape characters that
                // cannot be included in a string literal and then unescape them in code
                // blocks.
                var source = "__p+='" + text
                  .replace(settings.escape || noMatch, function(match, code) {
                    return "'+\n_.escape(" + unescape(code) + ")+\n'";
                  })
                  .replace(settings.interpolate || noMatch, function(match, code) {
                    return "'+\n(" + unescape(code) + ")+\n'";
                  })
                  .replace(settings.evaluate || noMatch, function(match, code) {
                    return "';\n" + unescape(code) + "\n;__p+='";
                  }) + "';\n";
            
                // If a variable is not specified, place data values in local scope.
                if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';
            
                source = "var __p='';" +
                  "var print=function(){__p+=Array.prototype.join.call(arguments, '')};\n" +
                  source + "return __p;\n";
            
                var render = new Function(settings.variable || 'obj', '_', source);
                if (data) return render(data, _);
                var template = function(data) {
                  return render.call(this, data, _);
                };
            
                // Provide the compiled function source as a convenience for build time
                // precompilation.
                template.source = 'function(' + (settings.variable || 'obj') + '){\n' +
                  source + '}';
            
                return template;
              };
            
              // Add a "chain" function, which will delegate to the wrapper.
              _.chain = function(obj) {
                return _(obj).chain();
              };
            
              // The OOP Wrapper
              // ---------------
            
              // If Underscore is called as a function, it returns a wrapped object that
              // can be used OO-style. This wrapper holds altered versions of all the
              // underscore functions. Wrapped objects may be chained.
              var wrapper = function(obj) { this._wrapped = obj; };
            
              // Expose `wrapper.prototype` as `_.prototype`
              _.prototype = wrapper.prototype;
            
              // Helper function to continue chaining intermediate results.
              var result = function(obj, chain) {
                return chain ? _(obj).chain() : obj;
              };
            
              // A method to easily add functions to the OOP wrapper.
              var addToWrapper = function(name, func) {
                wrapper.prototype[name] = function() {
                  var args = slice.call(arguments);
                  unshift.call(args, this._wrapped);
                  return result(func.apply(_, args), this._chain);
                };
              };
            
              // Add all of the Underscore functions to the wrapper object.
              _.mixin(_);
            
              // Add all mutator Array functions to the wrapper.
              each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
                var method = ArrayProto[name];
                wrapper.prototype[name] = function() {
                  var wrapped = this._wrapped;
                  method.apply(wrapped, arguments);
                  var length = wrapped.length;
                  if ((name == 'shift' || name == 'splice') && length === 0) delete wrapped[0];
                  return result(wrapped, this._chain);
                };
              });
            
              // Add all accessor Array functions to the wrapper.
              each(['concat', 'join', 'slice'], function(name) {
                var method = ArrayProto[name];
                wrapper.prototype[name] = function() {
                  return result(method.apply(this._wrapped, arguments), this._chain);
                };
              });
            
              // Start chaining a wrapped Underscore object.
              wrapper.prototype.chain = function() {
                this._chain = true;
                return this;
              };
            
              // Extracts the result from a wrapped and chained object.
              wrapper.prototype.value = function() {
                return this._wrapped;
              };
            
            }).call(this);
            (function() {
                var Ext = window.Ext4 || window.Ext;
            
                /**
                 * ComboBox for choosing allowed values for the field of a model
                 *
                 *     @example
                 *     Ext.create('Ext.Container', {
                 *         items: [{
                 *             xtype: 'rallyattributecombobox',
                 *             model: 'UserStory',
                 *             field: 'ScheduleState'
                 *         }],
                 *         renderTo: Ext.getBody().dom
                 *     });
                 */
                Ext.define('FieldComboBox', {
                    requires: ['Ext.Array'],
                    extend: 'Rally.ui.AttributeMultiComboBox',
                    alias: 'widget.defectfieldcombobox',
            
                    config: {
                        /**
                         * @cfg {Ext.data.Model/String} model (required) The model containing the specified field used to populate the store.
                         * Not required if field is an instance of Ext.data.Field.
                         */
                        model: undefined,
            
                        /**
                         * @cfg {Ext.data.Field/String} field (required) The model's field, whose allowed values will be used to populate the store.
                         */
                        field: undefined,
            
                        /**
                         * @cfg {Object} context An object specifying the scoping settings for retrieving the specified model
                         * If not specified the values provided by {Rally.env.Environment#getContext} will be used.
                         */
                        context: undefined,
            
                        /**
                         * @cfg {Object} storeConfig A configuration object which will be passed to the underlying data store
                         */
                        storeConfig: undefined,
            
                        queryMode: 'local',
                        editable: false,
                        valueField: 'value',
                        displayField: 'name'
                    },
            
                    /**
                     * @constructor
                     */
                    constructor: function(config) {
            
                        this.mergeConfig(config);
            
                        this.store = Ext.create('Ext.data.Store', {
                            fields: [this.valueField, this.displayField],
                            data: []
                        });
            
                        return this.callParent(arguments);
                    },
            
                    initComponent: function() {
            
                        this.callParent(arguments);
            
                        if(this.storeConfig && this.storeConfig.listeners) {
                            this.store.on(this.storeConfig.listeners);
                        }
                        this.on('afterrender', this._onAfterRender, this);
            
                        if (Ext.isString(this.model)) {
                            this._fetchModel();
                        } else {
                            if (Ext.isString(this.field)) {
                                this.field = this.model.getField(this.field);
                            }
                            this._populateStore();
                        }
                    },
            
                    _fetchModel: function() {
                        Rally.data.ModelFactory.getModel({
                            context: this.context,
                            type: this.model,
                            success: this._onModelRetrieved,
                            scope: this
                        });
                    },
            
                    _onModelRetrieved: function(model) {
                        this.model = model;
            			
            			var ignoredFields = [];
            			var allowedTypes = ['string', 'bool'];
            			var filterableFields = _.filter(model.getFields(), function(model){
            				var allowed = true;
            				allowed &= !model.hidden;
            				allowed &= _.indexOf(ignoredFields, model.name) === -1;
            				allowed &= (model.type.type === 'string' && model.allowedValues.length !== 0 || model.type.type === 'bool');
            				return allowed;
            			});
            			
            			var fieldTypes = {};
            			_.each(filterableFields, function(field){
            				fieldTypes[field.name] = field.type.type;
            			});
            			this.fieldTypes = fieldTypes;
            			
            			var fields = _.pluck(filterableFields, 'name');
            			
                        this._populateStore(fields);
                    },
            
                     _populateStore: function(fields) {
                         var allowedValues = [];
            			 for( var i in fields ){
                             var allowedValue = {};
                             allowedValue[this.valueField] = fields[i];
                             allowedValue[this.displayField] = fields[i];
                             allowedValues.push(allowedValue);
            			 }
                         this.store.loadRawData(allowedValues);
                     },
            
                    _onAfterRender: function() {
                        this._afterRender = true;
                        if(this._storeLoaded) {
                            this.fireEvent('ready', this);
                        }
                    },
            
                    onReady: function() {
                        this._storeLoaded = true;
                        if(this._afterRender) {
                            this.fireEvent('ready', this);
                        }
                    }
                });
            })();            (function() {
              var ChartTime, burnCalculator, lumenize, root, timeSeriesCalculator, utils;
              var __hasProp = Object.prototype.hasOwnProperty, __indexOf = Array.prototype.indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (__hasProp.call(this, i) && this[i] === item) return i; } return -1; };
            
              root = this;
            
              if (typeof exports !== "undefined" && exports !== null) {
                lumenize = require('../lib/lumenize');
              } else {
                lumenize = require('/lumenize');
              }
            
              ChartTime = lumenize.ChartTime, timeSeriesCalculator = lumenize.timeSeriesCalculator;
            
              utils = lumenize.utils;
            
              burnCalculator = function(results, config, valueField) {
                /*
                  Takes the "results" from a query to Rally's Analytics API (or similar MVCC-based implementation)
                  and returns the series for burn charts.
                */
                var aggregationAtArray, aggregations, categories, ct, derivedFields, f, field, granularity, i, idealData, idealStep, listOfAtCTs, maxTaskEstimateTotal, name, originalPointCount, pastEnd, rangeSpec, s, series, seriesFound, seriesNames, start, timeSeriesCalculatorConfig, type, yAxis, _i, _len, _ref, _ref2, _ref3;
                if (config.granularity != null) {
                  granularity = config.granularity;
                } else {
                  granularity = 'day';
                }
                start = config.start;
                if (utils.type(start) === 'string') {
                  start = new ChartTime(start, granularity, config.workspaceConfiguration.TimeZone);
                }
                pastEnd = new ChartTime(results[results.length - 1]._ValidFrom, granularity, config.workspaceConfiguration.TimeZone).add(1);
                rangeSpec = {
                  workDays: config.workspaceConfiguration.WorkDays,
                  holidays: config.holidays,
                  start: start,
                  pastEnd: pastEnd
                };
                if (config.upSeriesType == null) config.upSeriesType = 'Sums';
                derivedFields = [];
                if (config.upSeriesType === 'Points') {
                  derivedFields.push({
                    name: 'Accepted',
                    f: function(row) {
                      var _ref;
                      if (_ref = row.ScheduleState, __indexOf.call(config.acceptedStates, _ref) >= 0) {
                        return row.PlanEstimate;
                      } else {
                        return 0;
                      }
                    }
                  });
                } else if (config.upSeriesType === 'Story Count') {
                  derivedFields.push({
                    name: 'Accepted',
                    f: function(row) {
                      var _ref;
                      if (_ref = row.ScheduleState, __indexOf.call(config.acceptedStates, _ref) >= 0) {
                        return 1;
                      } else {
                        return 0;
                      }
                    }
                  });
                } else {
                  console.error("Unrecognized upSeriesType: " + config.upSeriesType);
                }
                seriesNames = [];
                aggregations = [];
                _ref = config.series;
                for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                  s = _ref[_i];
                  seriesFound = true;
                  switch (s) {
                    case 'down':
                      name = 'Task To Do (Hours)';
                      f = '$sum';
                      field = 'TaskRemainingTotal';
                      yAxis = 0;
                      type = 'column';
                      break;
                    case 'ideal':
                      name = "Ideal (Hours)";
                      f = '$sum';
                      field = 'TaskEstimateTotal';
                      yAxis = 0;
                      type = 'line';
                      break;
                    case 'up':
                      name = "Accepted (" + config.upSeriesType + ")";
                      f = '$sum';
                      field = 'Accepted';
                      yAxis = 1;
                      type = 'column';
                      break;
                    case 'scope':
                      name = valueField;
                      if (config.upSeriesType === 'Story Count') {
                        f = '$count';
                      } else if (config.upSeriesType === 'Points') {
                        f = '$sum';
                      }
                      field = 'PlanEstimate';
                      yAxis = 1;
                      type = 'line';
                      break;
                    default:
                      if ((s.name != null) && (s.f != null) && (s.field != null)) {
                        name = s.name;
                        f = s.f;
                        field = s.field;
                        type = 'column';
                      } else {
                        seriesFound = false;
                        console.error("Unrecognizable series: " + s);
                      }
                  }
                  if (seriesFound) {
                    aggregations.push({
                      name: name,
                      as: name,
                      f: f,
                      field: field,
                      yAxis: yAxis,
                      type: type
                    });
                    seriesNames.push(name);
                  }
                }
                timeSeriesCalculatorConfig = {
                  rangeSpec: rangeSpec,
                  derivedFields: derivedFields,
                  aggregations: aggregations,
                  timezone: config.workspaceConfiguration.TimeZone,
                  snapshotValidFromField: '_ValidFrom',
                  snapshotValidToField: '_ValidTo',
                  snapshotUniqueID: 'ObjectID'
                };
                _ref2 = lumenize.timeSeriesCalculator(results, timeSeriesCalculatorConfig), listOfAtCTs = _ref2.listOfAtCTs, aggregationAtArray = _ref2.aggregationAtArray;
                series = lumenize.aggregationAtArray_To_HighChartsSeries(aggregationAtArray, aggregations);
                categories = (function() {
                  var _j, _len2, _results;
                  _results = [];
                  for (_j = 0, _len2 = listOfAtCTs.length; _j < _len2; _j++) {
                    ct = listOfAtCTs[_j];
                    _results.push("" + (ct.toString()));
                  }
                  return _results;
                })();
                originalPointCount = categories.length;
                if (__indexOf.call(config.series, "Ideal") >= 0) {
                  i = 0;
                  while (series[i].name.indexOf("Ideal") < 0) {
                    i++;
                  }
                  idealData = series[i].data;
                  maxTaskEstimateTotal = lumenize.functions.$max(idealData);
                  idealStep = maxTaskEstimateTotal / (originalPointCount - 1);
                  for (i = 0, _ref3 = originalPointCount - 2; 0 <= _ref3 ? i <= _ref3 : i >= _ref3; 0 <= _ref3 ? i++ : i--) {
                    idealData[i] = (originalPointCount - 1 - i) * idealStep;
                  }
                  idealData[originalPointCount - 1] = 0;
                }
                return {
                  categories: categories,
                  series: series
                };
              };
            
              root.burnCalculator = burnCalculator;
            
            }).call(this);
            (function () {
            
                Ext.define('Rally.app.analytics.BurnChartBuilder', {
                    build:function (requestedQuery, startTime, endTime, chartTitle, buildFinishedCallback) {
            			this.requestedQuery = requestedQuery;
            			this.startTime = startTime;
            			this.endTime = endTime;
            			this.chartTitle = chartTitle;
            			this.buildFinishedCallback = buildFinishedCallback;
            		
                        this.workspace = Rally.util.Ref.getOidFromRef(Rally.environment.getContext().context.scope.workspace._ref);
            			
                        var singleDefectQuery = {
                            find:Ext.encode(this.requestedQuery.find),
                            pagesize:1
                        };
            			
            			// query to get earliest defect    
                        Ext.Ajax.request({
                            url:"https://rally1.rallydev.com/analytics/1.27/" + this.workspace + "/artifact/snapshot/query.js?" + Ext.Object.toQueryString(singleDefectQuery) +
                                "&fields=['_ValidFrom']&sort={_ValidFrom:1}",
                            method:"GET",
                            success:function (response) {
                                this._earliestDefectFound(JSON.parse(response.responseText));
                            },
                            scope:this
                        });
            
                    },
            		
            		_earliestDefectFound: function(response) {
            			var earliestValidFrom = this.endTime;
            			if (response.Results.length > 0) {
            				earliestValidFrom = response.Results[0]._ValidFrom;
            			}
            			
            			this.requestedQuery.find._ValidFrom = {
            				$gte: earliestValidFrom,
            				$lt: this.endTime
            			};
            			
            			this._buildChart();
            		},
            		
            		_buildChart: function() {
                        this.query = {
                            find:Ext.encode(this.requestedQuery.find),
                            pagesize:10000
                        };
                        this.requestedFields = Ext.Array.union(['_ValidFrom', '_ValidTo', 'ObjectID'], this.requestedQuery.fields ? this.requestedQuery.fields : []);
            
            
            			this._queryAnalyticsApi();
            		},
            		
                    _queryAnalyticsApi:function () {
                        Ext.Ajax.request({
                            url:"https://rally1.rallydev.com/analytics/1.27/" + this.workspace + "/artifact/snapshot/query.js?" + Ext.Object.toQueryString(this.query) +
                                "&fields=" + JSON.stringify(this.requestedFields) + "&sort={_ValidFrom:1}",
                            method:"GET",
                            success:function (response) {
                                this._afterQueryReturned(JSON.parse(response.responseText));
                            },
                            scope:this
                        });
                    },
            
                    _afterQueryReturned:function (queryResultsData) {
                        if (queryResultsData.TotalResultCount > 0) {
                            this._buildChartConfigAndCallback(queryResultsData);
                        } else {
                            this.buildFinishedCallback(false);
                        }
                    },
            
                    _buildChartConfigAndCallback: function(queryResultsData) {
                        var lumenize = require('./lumenize');
                            var contextWorkspaceConfig = Rally.environment.getContext().context.scope.workspace.WorkspaceConfiguration;
                            var workspaceConfiguration = {
                                // Need to grab from Rally for this user
                                DateFormat:contextWorkspaceConfig.DateFormat,
                                DateTimeFormat:contextWorkspaceConfig.DateTimeFormat,
                                //TODO: Have context code fetch these values for the workspace config, instead of hardcoding them
                                IterationEstimateUnitName:'Points',
                                // !TODO: Should we use this?
                                ReleaseEstimateUnitName:'Points',
                                TaskUnitName:'Hours',
                                TimeTrackerEnabled:true,
                                TimeZone:'America/Denver',
                                WorkDays:'Sunday,Monday,Tuesday,Wednesday,Thursday,Friday'
                                // They work on Sundays
                            };
            
                            var burnConfig = {
                                workspaceConfiguration:workspaceConfiguration,
                                upSeriesType:'Story Count',
                                // 'Points' or 'Story Count'
                                series:[
                                    'scope'
                                ],
            
                                acceptedStates:[],
                                start:this.startTime,
                                // Calculated either by inspecting results or via configuration. pastEnd is automatically the last date in results
                                holidays:[
                                    {
                                        month:12,
                                        day:25
                                    },
                                    {
                                        year:2011,
                                        month:11,
                                        day:26
                                    },
                                    {
                                        year:2011,
                                        month:1,
                                        day:5
                                    }
                                ]
                            };
            
                            lumenize.ChartTime.setTZPath("");
                            var tscResults = burnCalculator(queryResultsData.Results, burnConfig, this.chartTitle);
            
                            var categories = tscResults.categories;
                            var series = tscResults.series;
                            var chartConfiguration = {
                                chart:{
                                    defaultSeriesType:'column',
                                    zoomType: 'xy'
                                },
                                credits:{
                                    enabled:false
                                },
                                title:{
                                    text:this.chartTitle
                                },
                                subtitle:{
                                    text:''
                                },
                                xAxis:{
                                    categories:categories,
                                    tickmarkPlacement:'on',
                                    tickInterval:Math.floor(categories.length / 13) + 1,
                                    // set as a function of the length of categories
                                    title:{
                                        enabled:false
                                    }
                                },
                                yAxis:[
                                    {
                                        title:{
                                            text:this.chartTitle
                                        },
                                        labels:{
                                            formatter:function () {
                                                return this.value / 1;
                                            }
                                        },
                                        min:0
                                    },
                                    {
                                        title:{
                                            text:''
                                        },
                                        opposite:true,
                                        labels:{
                                            formatter:function () {
                                                return this.value / 1;
                                            }
                                        },
                                        min:0
                                    }
                                ],
                                tooltip:{
                                    formatter:function () {
                                        return '' + this.x + '<br />' + this.series.name + ': ' + this.y;
                                    }
                                },
                                plotOptions:{
                                    column:{
                                        stacking:null,
                                        lineColor:'#666666',
                                        lineWidth:1,
                                        marker:{
                                            lineWidth:1,
                                            lineColor:'#666666'
                                        }
                                    }
                                },
                                series:series
                            };
            
                            this.buildFinishedCallback(true, chartConfiguration);
                    }
                });
            })();            Ext.define('OnDemandCustomAnalytics', {
                extend:'Rally.app.App',
                mixins: {
                    messageable: 'Rally.Messageable'
                },
                layout: {
                    type: 'hbox',
                    align: 'stretch'
                },
                appName:'On-Demand Custom Analytics',
                cls:'burnchart',
            	_labelWidth: 120,
            	_padding: '2 0 0 0',
            
                launch: function () {
                    this.chartConfigBuilder = Ext.create('Rally.app.analytics.BurnChartBuilder');
            
            		var reportControls = this._buildReportControls();
            		var chartFilteringControls = this._buildChartFilteringControls();
            
            		// Button
            		var runQueryButton = Ext.create('Ext.Container', {
            			items: [{
            				xtype: 'rallybutton',
            				text: 'Build Chart',
            				handler: Ext.bind(this._refreshChart, this)
            			}]
            		});
            
            		var leftNavigation = Ext.create('Ext.Container', {
            			items: [reportControls, chartFilteringControls, runQueryButton],
            			flex: 1,
            			defaults: {
            				padding: '5 0 0 5'
            			}
            		});
            
            		this.add(leftNavigation);
            		this.add({
            			id: 'chartCmp',
            			flex: 2,
            			border: 0
            		});
                },
            
            	_buildReportControls: function () {
            		var reportContainer = Ext.create('Ext.panel.Panel', {
            			title: 'Standard Reports',
            			layout: {
            				type: 'anchor'
            			},
            			defaults: {
            				padding: this._padding,
            				anchor: '100%'
            			}
            		});
            
            		this.reportStore = Ext.create('Ext.data.Store', {
            			fields: ['display'],
            			data: [
                            {'display': 'Portfolio Items: Horizon 1 Must Haves'},
            				{'display': 'Defects: Not Closed, Released and Critical/High'},
            				{'display': 'Defects: Not Closed and Blocked'},
            				{'display': 'Defects: Fixed/Resolved'},
            				{'display': 'User Stories: In-Progress and Blocked'}
            			],
            			filterInfo: {
                            "Portfolio Items: Horizon 1 Must Haves":{
                              Type: "PortfolioItem",
                              InvestmentCategory:["Horizon 1"],
                              Priority:["Must Have"]
                            },
                            "User Stories: In-Progress and Blocked": {
                                Type: 'HierarchicalRequirement',
                                ScheduleState: ['In-Progress'],
                                Blocked: [true]
                            },
                            'Defects: Not Closed, Released and Critical/High': {
            					Type: 'Defect',
            					State: ['Submitted', 'Open', 'Fixed/Resolved'],
            					ReleasedDefect: [true],
            					Priority: ['Critical', 'High']
            				},
                            "Defects: Not Closed and Blocked": {
            					Type: 'Defect',
            					State: ['Submitted', 'Open', 'Fixed/Resolved'],
            					Blocked: [true]
            				},
                            "Defects: Fixed/Resolved": {
            					Type: 'Defect',
            					State: ['Fixed/Resolved']
            				}
            			}
            		});
            
            		this.reportComboBox = Ext.create('Ext.form.field.ComboBox', {
            			fieldLabel: "Report",
            			labelWidth: this._labelWidth,
            			store: this.reportStore,
            			queryMode: 'local',
            			displayField: 'display',
            			valueField: 'display',
            			padding: this._padding,
            			editable: false
            		});
            		this.reportComboBox.addListener('select', this._reportSelected, this);
            
            		reportContainer.add(this.reportComboBox);
            
            		return reportContainer;
            	},
            
            	_reportSelected: function(comboBox, records){
            		var selectedReport = records[0].data.display;
            		var filterInfo = this.reportStore.filterInfo[selectedReport];
            
                    var type = filterInfo['Type'];
                    this.typeFilter.setValue(type);
                    this.typeFilter.fireEvent('select',null,[{
                        data:{
                            value: type
                        }
                    }]);
            
            		this._setCustomFilters(filterInfo);
            	},
            
            	_setCustomFilters: function(filterInfo) {
            		var fields = _.keys(filterInfo);
            		fields = _.without(fields,'Type');
                    this.currentTypeFilter.setValue(fields);
            
            		for(var key in filterInfo)
            		{
            			var cntrl = Ext.getCmp(key);
            			if(_.isUndefined(cntrl)) {
            				alert('Missing control: ' + key);
            			}
            			else {
            				cntrl.setValue(filterInfo[key]);
            			}
            		}
            	},
            
            	_buildChartFilteringControls: function() {
            		var filterContainer = Ext.create('Ext.panel.Panel', {
            			title: 'Chart Filtering',
            			layout: {
            				type: 'anchor'
            			},
            			defaults: {
            				padding: this._padding,
            				anchor: '100%'
            			}
            		});
            
            		var typeStore = Ext.create('Ext.data.Store', {
            			fields: ['display', 'value'],
            			data: [
            				{'display': 'Portfolio Item', value: 'PortfolioItem'},
            				{'display': 'Defect', value: 'Defect'},
            				{'display': 'User Story', value: 'HierarchicalRequirement'},
            				{'display': 'Task', value: 'Task'}
            			]
            		});
            
            		// Type Filter
            		this.typeFilter = Ext.create('Rally.ui.ComboBox', {
            			id: 'Type',
            			fieldLabel: 'Data Type',
            			labelWidth: this._labelWidth,
            			store: typeStore,
            			queryMode: 'local',
            			displayField: 'display',
            			valueField: 'value',
            			listeners: {
            				select: Ext.bind(this._typeFilterSelected, this)
            			}
            		});
            		this.typeFilterContainer = Ext.create('Ext.Container', {
            			items: [this.typeFilter],
            			layout: 'anchor',
            			defaults: {
            				anchor: '100%'
            			}
            		});
            		filterContainer.add( this.typeFilterContainer );
            
            		// Start and End time
            		this.startTimePicker = Ext.create('Rally.ui.DateField', {
            			fieldLabel: 'Start Date',
            			labelWidth: this._labelWidth,
            			value: new Date().add(-3).month()
            		});
            		this.startTimePickerContainer = Ext.create('Ext.Container', {
            			items: [this.startTimePicker],
            			layout: 'anchor',
            			defaults: {
            				anchor: '100%'
            			}
            		});
            		filterContainer.add( this.startTimePickerContainer );
            
            		this.endTimePicker = Ext.create('Rally.ui.DateField', {
            			fieldLabel: 'End Date',
            			labelWidth: this._labelWidth,
            			value: new Date().add(1).days()
            		});
            		this.endTimePickerContainer = Ext.create('Ext.Container', {
            			items: [this.endTimePicker],
            			layout: 'anchor',
            			defaults: {
            				anchor: '100%'
            			}
            		});
            		filterContainer.add( this.endTimePickerContainer );
            
            		// Customer Filter Picker
            		this.piFieldPicker = Ext.create('FieldComboBox', {
            			model: 'PortfolioItem',
            			fieldLabel: 'Custom Filters',
            			labelWidth: this._labelWidth,
            			multiSelect: true,
            			hidden: true,
            			listeners:{
            				change: Ext.bind(this._defectFieldSelectionChanged, this)
            			}
            		});
            		this.defectFieldPicker = Ext.create('FieldComboBox', {
            			model: 'Defect',
            			fieldLabel: 'Custom Filters',
            			labelWidth: this._labelWidth,
            			multiSelect: true,
            			hidden: true,
            			listeners:{
            				change: Ext.bind(this._defectFieldSelectionChanged, this)
            			}
            		});
            		this.storyFieldPicker = Ext.create('FieldComboBox', {
            			model: 'HierarchicalRequirement',
            			fieldLabel: 'Custom Filters',
            			labelWidth: this._labelWidth,
            			multiSelect: true,
            			hidden: true,
            			listeners:{
            				change: Ext.bind(this._defectFieldSelectionChanged, this)
            			}
            		});
            		this.taskFieldPicker = Ext.create('FieldComboBox', {
            			model: 'Task',
            			fieldLabel: 'Custom Filters',
            			labelWidth: this._labelWidth,
            			multiSelect: true,
            			hidden: true,
            			listeners:{
            				change: Ext.bind(this._defectFieldSelectionChanged, this)
            			}
            		});
            
            		this.typeFieldPickerContainer = Ext.create('Ext.Container', {
            			items: [this.piFieldPicker, this.defectFieldPicker, this.storyFieldPicker, this.taskFieldPicker ],
            			layout: 'anchor',
            			defaults: {
            				anchor: '100%'
            			}
            		});
            		filterContainer.add( this.typeFieldPickerContainer );
            
            		// Custom Filter Container
            		this.customFilterContainer = Ext.create('Ext.panel.Panel', {
            			title: 'Custom Filters',
            			hidden: true,
            			padding: '5 5 5 5',
            			items: [],
            			layout: 'anchor',
            			defaults: {
            				padding: this._padding,
            				anchor: '100%'
            			}
            		});
            		filterContainer.add( this.customFilterContainer );
            
            		return filterContainer;
            	},
            
            	_typeFilterSelected: function(comboBox, records) {
            		if(this.currentTypeFilter) {
            			this.currentTypeFilter.hide();
            			this._setCustomFilters({});
            		}
            
            		if(records[0].data.value === 'Defect') {
            			this.currentTypeFilter = this.defectFieldPicker;
            			this._setCustomFilters(
            				{
            					State: ['Submitted', 'Open', 'Fixed/Resolved']
            				}
            			);
            		} else if (records[0].data.value === 'HierarchicalRequirement')  {
            			this.currentTypeFilter = this.storyFieldPicker;
            			this._setCustomFilters(
            				{
            					ScheduleState: [ 'In-Progress' ]
            				}
            			);
            		} else if (records[0].data.value === 'Task') {
            			this.currentTypeFilter = this.taskFieldPicker;
            			this._setCustomFilters(
            				{
            				}
            			);
            		} else if (records[0].data.value === 'PortfolioItem') {
            			this.currentTypeFilter = this.piFieldPicker;
            			this._setCustomFilters(
            				{
            				}
            			);
            		}
            		this.currentTypeFilter.show();
            
            	},
            
            	_defectFieldSelectionChanged: function(comboBox, newFields, oldFields){
            		newFields = _.isUndefined(newFields) || newFields.length === 0 ? [] : newFields.split(', ');
            		oldFields = _.isUndefined(oldFields) || oldFields.length === 0  ? [] : oldFields.split(', ');
            
            		var added = _.difference(newFields, oldFields);
            		var removed = _.difference(oldFields, newFields);
            
            		if(newFields.length === 0)
            			this.customFilterContainer.hide();
            		else
            			this.customFilterContainer.show();
            
            		for (var i in added) {
            			if(this.currentTypeFilter.fieldTypes[added[i]] === 'bool') {
            				var filterStore = Ext.create('Ext.data.Store', {
            					fields: ['display', 'value'],
            					data: [
            						{"display":'True', value: true},
            						{"display":'False', value: false}
            					]
            				});
            
            				var newFilter = Ext.create('Ext.ux.form.field.BoxSelect', {
            					id: added[i],
            					fieldLabel: added[i],
            					labelWidth: this._labelWidth,
            					multiSelect: true,
            					store: filterStore,
            					queryMode: 'local',
            					displayField: 'display',
            					valueField: 'value'
            				});
            			}
            			else {
            				var newFilter = Ext.create('Rally.ui.AttributeMultiComboBox', {
            					id: added[i],
            					model: this.typeFilter.getValue(),
            					field: added[i],
            					fieldLabel: added[i],
            					labelWidth: this._labelWidth,
            					multiSelect: true
            				});
            			}
            			this.customFilterContainer.add(newFilter);
            		}
            		for (var i in removed) {
            			this.customFilterContainer.remove(Ext.getCmp(removed[i]));
            		}
            
            		this.customFilterContainer.doLayout();
            	},
            
            	_afterChartConfigBuilt: function (success, chartConfig) {
            		this.getEl().unmask('Loading...');
                    this._removeChartComponent();
                    if (success){
                        this.add({
                            id: 'chartCmp',
                            xtype: 'highchart',
                            flex: 2,
                            chartConfig: chartConfig
                        });
                    } else {
                        this.add({
                            id: 'chartCmp',
            				flex: 2,
                            xtype: 'component',
                            html: '<div>No ' + this.typeFilter.getRawValue() + ' data found for the specified query.</div>'
                        });
                    }
                },
            
                _removeChartComponent: function() {
                    var chartCmp = this.down('#chartCmp');
                    if (chartCmp) {
                        this.remove(chartCmp);
                    }
                },
            
                _refreshChart: function() {
            		this.chartQuery = this._buildChartQuery();
            		this.getEl().mask('Loading...');
            		this.chartConfigBuilder.build(this.chartQuery, this.startTimePicker.getValue().toISOString(), this.endTimePicker.getValue().toISOString(),
            			this.typeFilter.getRawValue() + " Count", Ext.bind(this._afterChartConfigBuilt, this));
                },
            
            	_buildChartQuery: function(){
                    var chartQuery = {
                        find:{
                            _Type: this.typeFilter.getValue()
                        }
                    };
            
            		chartQuery.find._ProjectHierarchy = Rally.environment.getContext().getScope().project.ObjectID;
            
            		var filterItems = this.customFilterContainer.query('pickerfield');
            		for (var i in filterItems)
            		{
            			var filterItem = filterItems[i];
            			chartQuery.find[filterItem.id] = {$in:filterItem.getValue()};
            		}
            
            		return chartQuery;
            	}
            });

            Rally.launchApp('OnDemandCustomAnalytics', {
                name: 'On-Demand Custom Analytics'
            });
        });
    </script>

    <style type="text/css">
        .app {
        
        }
        
        .rallytree {
            overflow: auto;
        }
        
        .treeItem .pill .row-action {
            display: none;
        }
        
        .treeItem .pill {
            cursor: pointer;
        }
        .x-boxselect ul.x-boxselect-list {
            height: auto;
            cursor: text;
            min-height: 20px;
            padding: 0px;
            overflow-y: auto;
            overflow-x: hidden;
        }
        
        .x-boxselect input {
            border: none;
            background: none;
            line-height: 18px;
            height: 20px;
            width: 100%;
            padding: 1px 3px;
        }
        .x-boxselect-input, .x-boxselect-item {
            display: inline-block;
            position: relative;
            *display:inline; /* IE7 */
            zoom:1; /* IE */
        }
        .x-boxselect-stacked .x-boxselect-item {
            display: block;
        }
        .x-boxselect-item {
            -moz-border-radius: 6px; -webkit-border-radius: 6px; border-radius: 6px; o-border-radius: 6px; khtml-border-radius: 6px; border: 1px solid #CAD8F3;
            padding: 0px 1px 0px 5px !important;
            margin: 1px 1px 1px 0;
            background-color: #DEE7F8;
            cursor: default;
        }
        .x-field:not(.x-item-disabled) .x-boxselect-item:hover {
            background: #BBCEF1;
            border: 1px solid #6D95E0;
        }
        .x-field:not(.x-item-disabled) .x-boxselect-item.selected {
            border: 1px solid #316AD3 !important;
            background: #658FDC !important;
        }
        .x-boxselect-item-text {
            line-height: 16px;
            padding-right: 20px;
        }
        .x-boxselect-item-close {
            cursor: pointer;
        }    </style>
</head>
<body></body>
</html>
